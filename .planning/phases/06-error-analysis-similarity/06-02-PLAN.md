---
phase: 06-error-analysis-similarity
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/similarity_service.py
  - app/models/similarity.py
  - app/routers/similarity.py
  - app/config.py
  - app/main.py
  - app/dependencies.py
  - frontend/src/types/similarity.ts
  - frontend/src/hooks/use-similarity.ts
  - frontend/src/components/detail/similarity-panel.tsx
  - frontend/src/components/detail/sample-modal.tsx
autonomous: true

must_haves:
  truths:
    - "User can click 'Find Similar' on any sample and see visually similar images ranked by score"
    - "Similar images display as a thumbnail grid with cosine similarity scores"
    - "Clicking a similar image navigates to that sample in the detail modal"
    - "Qdrant collection syncs lazily from DuckDB embeddings on first query"
  artifacts:
    - path: "app/services/similarity_service.py"
      provides: "Qdrant local-mode lifecycle and similarity search"
      exports: ["SimilarityService"]
    - path: "app/models/similarity.py"
      provides: "Pydantic models for similarity request/response"
      exports: ["SimilarResult", "SimilarityResponse"]
    - path: "app/routers/similarity.py"
      provides: "GET /datasets/{id}/similarity/search endpoint"
      contains: "search_similar"
    - path: "frontend/src/components/detail/similarity-panel.tsx"
      provides: "Thumbnail grid of similar images with scores"
    - path: "frontend/src/components/detail/sample-modal.tsx"
      provides: "'Find Similar' button triggering similarity search"
      contains: "Find Similar"
  key_links:
    - from: "app/routers/similarity.py"
      to: "app/services/similarity_service.py"
      via: "find_similar method call"
      pattern: "find_similar"
    - from: "app/services/similarity_service.py"
      to: "Qdrant local client"
      via: "QdrantClient(path=qdrant_path)"
      pattern: "QdrantClient"
    - from: "app/main.py"
      to: "app/services/similarity_service.py"
      via: "lifespan initialization"
      pattern: "SimilarityService"
    - from: "frontend/src/hooks/use-similarity.ts"
      to: "/datasets/{id}/similarity/search"
      via: "TanStack useQuery fetch"
      pattern: "similarity/search"
    - from: "frontend/src/components/detail/sample-modal.tsx"
      to: "frontend/src/components/detail/similarity-panel.tsx"
      via: "conditional render on Find Similar click"
      pattern: "SimilarityPanel"
---

<objective>
Add Qdrant-powered similarity search: a backend service that syncs DINOv2 embeddings to Qdrant local mode and finds visually similar images, plus a "Find Similar" button in the SampleModal that shows ranked results.

Purpose: Users exploring a dataset need to quickly find images that look similar to a given sample -- for finding duplicates, understanding cluster composition, or verifying annotation consistency across similar images. Qdrant's HNSW index provides sub-linear query time that scales beyond brute-force.

Output: SimilarityService with Qdrant lifecycle, REST endpoint for similarity search, "Find Similar" button in SampleModal with thumbnail grid of results.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Qdrant local mode patterns, lifecycle, and pitfalls
@.planning/phases/06-error-analysis-similarity/06-RESEARCH.md

# DuckDB embeddings table schema (FLOAT[768], sample_id, dataset_id)
@app/repositories/duckdb_repo.py

# Existing service patterns: lifespan init, DI, app.state
@app/main.py
@app/dependencies.py
@app/config.py

# Sample modal where "Find Similar" button will be added
@frontend/src/components/detail/sample-modal.tsx

# API helper with thumbnailUrl
@frontend/src/lib/api.ts

# Embedding service for reference (embedding generation, model lifecycle)
@app/services/embedding_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Qdrant similarity service, models, config, DI, and API endpoint</name>
  <files>
    app/services/similarity_service.py
    app/models/similarity.py
    app/routers/similarity.py
    app/config.py
    app/main.py
    app/dependencies.py
  </files>
  <action>
    **1. Install qdrant-client:**
    ```bash
    uv add qdrant-client
    ```

    **2. Add qdrant_path to `app/config.py`:**
    Add field to Settings class:
    ```python
    qdrant_path: Path = Path("data/qdrant")
    ```

    **3. Create `app/models/similarity.py`:**
    - `SimilarResult`: sample_id (str), score (float), file_name (str | None), thumbnail_path (str | None)
    - `SimilarityResponse`: results (list[SimilarResult]), query_sample_id (str)

    **4. Create `app/services/similarity_service.py`:**

    ```python
    class SimilarityService:
        def __init__(self, qdrant_path: str | Path, db: DuckDBRepo):
            self.client = QdrantClient(path=str(qdrant_path))
            self.db = db

        def ensure_collection(self, dataset_id: str) -> str:
            """Create Qdrant collection if not exists, sync from DuckDB."""
            collection_name = f"embeddings_{dataset_id}"
            if not self.client.collection_exists(collection_name):
                self.client.create_collection(
                    collection_name=collection_name,
                    vectors_config=VectorParams(size=768, distance=Distance.COSINE),
                )
                self._sync_from_duckdb(dataset_id, collection_name)
            return collection_name

        def _sync_from_duckdb(self, dataset_id: str, collection_name: str):
            """Load embeddings from DuckDB embeddings table and upsert to Qdrant."""
            cursor = self.db.connection.cursor()
            try:
                rows = cursor.execute(
                    "SELECT sample_id, vector FROM embeddings "
                    "WHERE dataset_id = ? AND vector IS NOT NULL",
                    [dataset_id],
                ).fetchall()

                points = [
                    PointStruct(
                        id=idx,
                        vector=list(row[1]),  # FLOAT[768] from DuckDB -> list
                        payload={"sample_id": row[0], "dataset_id": dataset_id},
                    )
                    for idx, row in enumerate(rows)
                ]

                BATCH_SIZE = 500
                for i in range(0, len(points), BATCH_SIZE):
                    self.client.upsert(
                        collection_name=collection_name,
                        points=points[i : i + BATCH_SIZE],
                    )
            finally:
                cursor.close()

        def invalidate_collection(self, dataset_id: str):
            """Drop collection so it re-syncs on next query. Call after re-embedding."""
            collection_name = f"embeddings_{dataset_id}"
            if self.client.collection_exists(collection_name):
                self.client.delete_collection(collection_name)

        def find_similar(self, dataset_id: str, sample_id: str, limit: int = 20) -> list[dict]:
            """Find similar images by embedding distance."""
            collection_name = self.ensure_collection(dataset_id)

            # Get query vector from DuckDB
            cursor = self.db.connection.cursor()
            try:
                row = cursor.execute(
                    "SELECT vector FROM embeddings "
                    "WHERE dataset_id = ? AND sample_id = ?",
                    [dataset_id, sample_id],
                ).fetchone()
            finally:
                cursor.close()

            if not row or row[0] is None:
                return []

            results = self.client.query_points(
                collection_name=collection_name,
                query=list(row[0]),
                limit=limit + 1,  # +1 to exclude self
                with_payload=True,
            ).points

            return [
                {"sample_id": r.payload["sample_id"], "score": r.score}
                for r in results
                if r.payload["sample_id"] != sample_id
            ][:limit]

        def close(self):
            """Close Qdrant client."""
            self.client.close()
    ```

    Key details:
    - Use `QdrantClient(path=str(qdrant_path))` for local disk mode (no Docker)
    - Point IDs are sequential integers (0, 1, 2...), sample_id stored in payload (Qdrant requires int/UUID IDs)
    - `ensure_collection` is lazy -- creates and syncs only on first query
    - `invalidate_collection` drops the collection so it re-syncs on next similarity query (call this when embeddings are re-generated)
    - query_points returns results sorted by score descending (best match first)
    - Filter out the query sample itself from results

    **5. Update `app/main.py` lifespan:**
    - Import SimilarityService
    - After reduction_service initialization, add:
      ```python
      similarity_service = SimilarityService(
          qdrant_path=settings.qdrant_path, db=db
      )
      app.state.similarity_service = similarity_service
      ```
    - In shutdown section, add `similarity_service.close()` before `db.close()`

    **6. Update `app/dependencies.py`:**
    - Import SimilarityService
    - Add:
      ```python
      def get_similarity_service(request: Request) -> SimilarityService:
          return request.app.state.similarity_service
      ```

    **7. Create `app/routers/similarity.py`:**

    ```python
    router = APIRouter(prefix="/datasets", tags=["similarity"])

    @router.get("/{dataset_id}/similarity/search")
    def search_similar(
        dataset_id: str,
        sample_id: str = Query(..., description="Source sample to find similar images for"),
        limit: int = Query(20, ge=1, le=100),
        similarity_service: SimilarityService = Depends(get_similarity_service),
        db: DuckDBRepo = Depends(get_db),
    ) -> SimilarityResponse:
    ```

    Implementation:
    - Verify dataset exists (404 if not)
    - Call `similarity_service.find_similar(dataset_id, sample_id, limit)`
    - If empty results, return SimilarityResponse with empty list (NOT 404 -- user should see "no similar images found")
    - Enrich results with sample metadata: query DuckDB for file_name and thumbnail_path of all result sample_ids
    - Return SimilarityResponse with enriched SimilarResult objects

    **8. Register router in `app/main.py`:**
    - Import similarity router: `from app.routers import similarity`
    - Add: `app.include_router(similarity.router)`
  </action>
  <verify>
    1. Install: `uv add qdrant-client` succeeds
    2. Start backend: `uv run uvicorn app.main:app --reload`
    3. For a dataset with embeddings generated, test:
    ```bash
    curl "http://localhost:8000/datasets/{DATASET_ID}/similarity/search?sample_id={SAMPLE_ID}&limit=10" | python -m json.tool
    ```
    Response must contain `results` array with objects having `sample_id`, `score`, `file_name`, `thumbnail_path`. Scores should be between 0 and 1 (cosine similarity). The query sample itself must NOT appear in results.
    4. Verify Qdrant data directory created at `data/qdrant/`
  </verify>
  <done>
    GET /datasets/{id}/similarity/search returns ranked similar images with cosine similarity scores. Qdrant collection created lazily on first query. Results enriched with sample metadata. Query sample excluded from results.
  </done>
</task>

<task type="auto">
  <name>Task 2: "Find Similar" button in SampleModal with similarity results panel</name>
  <files>
    frontend/src/types/similarity.ts
    frontend/src/hooks/use-similarity.ts
    frontend/src/components/detail/similarity-panel.tsx
    frontend/src/components/detail/sample-modal.tsx
  </files>
  <action>
    **1. Create `frontend/src/types/similarity.ts`:**
    - `SimilarResult`: { sample_id: string; score: number; file_name: string | null; thumbnail_path: string | null }
    - `SimilarityResponse`: { results: SimilarResult[]; query_sample_id: string }

    **2. Create `frontend/src/hooks/use-similarity.ts`:**
    - `useSimilarity(datasetId: string, sampleId: string | null, limit?: number)`:
      - Returns useQuery result
      - Query key: `["similarity", datasetId, sampleId, limit]`
      - Fetch URL: `${API_BASE}/datasets/${datasetId}/similarity/search?sample_id=${sampleId}&limit=${limit || 20}`
      - enabled: `!!datasetId && !!sampleId` (don't fetch until user clicks "Find Similar")
      - staleTime: 60_000 (1 min -- same embeddings produce same results)
      - **Important:** This hook should NOT auto-fetch. Use `enabled: false` by default and provide a `refetch` function. OR: use a separate state variable `isEnabled` that the button toggles.
      - Better approach: Accept an `enabled` boolean parameter so the SampleModal can control when to fetch:
        ```typescript
        export function useSimilarity(
          datasetId: string,
          sampleId: string | null,
          limit: number = 20,
          enabled: boolean = false,
        )
        ```

    **3. Create `frontend/src/components/detail/similarity-panel.tsx`:**

    A panel showing similar image results:
    - Props: `{ datasetId: string; results: SimilarResult[]; isLoading: boolean; onSelectSample: (sampleId: string) => void }`
    - Grid layout: 4 columns (grid-cols-4) with gap-2
    - Each cell: thumbnail image (use `thumbnailUrl(datasetId, result.sample_id, "small")` from `@/lib/api`), overlaid with similarity score badge (bottom-right, white text on black/60 background, showing percentage like "92%")
    - Clicking a thumbnail calls `onSelectSample(result.sample_id)` which navigates to that sample in the modal
    - Loading state: 8 skeleton thumbnails (animate-pulse)
    - Empty state: "No similar images found. Generate embeddings first."
    - Show file_name on hover (title attribute)

    **4. Update `frontend/src/components/detail/sample-modal.tsx`:**

    Add "Find Similar" button and similarity panel:
    - Import `useSimilarity` hook and `SimilarityPanel` component
    - Add local state: `const [showSimilar, setShowSimilar] = useState(false)`
    - Reset showSimilar when selectedSampleId changes: `useEffect(() => { setShowSimilar(false); }, [selectedSampleId])`
    - Call hook: `const { data: similarityData, isLoading: similarityLoading } = useSimilarity(datasetId, selectedSampleId, 20, showSimilar)`
    - Add "Find Similar" button in the metadata panel (left column), below the dl element:
      ```tsx
      <button
        onClick={() => setShowSimilar(!showSimilar)}
        className="mt-3 w-full rounded-lg bg-blue-50 px-3 py-2 text-sm font-medium text-blue-600 transition-colors hover:bg-blue-100 dark:bg-blue-900/30 dark:text-blue-400 dark:hover:bg-blue-900/50"
      >
        {showSimilar ? "Hide Similar" : "Find Similar"}
      </button>
      ```
    - Below the existing grid layout (metadata + annotations), conditionally render SimilarityPanel:
      ```tsx
      {showSimilar && (
        <div className="border-t border-zinc-200 dark:border-zinc-700 p-5">
          <h3 className="text-sm font-semibold text-zinc-700 dark:text-zinc-300 mb-3">
            Similar Images
          </h3>
          <SimilarityPanel
            datasetId={datasetId}
            results={similarityData?.results ?? []}
            isLoading={similarityLoading}
            onSelectSample={(sampleId) => {
              // Navigate to the clicked similar sample in the same modal
              useUIStore.getState().openDetailModal(sampleId);
            }}
          />
        </div>
      )}
      ```

    Key details:
    - "Find Similar" is a toggle button (click again to hide)
    - Clicking a similar image thumbnail opens that sample in the same modal (replaces current sample)
    - When modal sample changes, showSimilar resets to false
    - The similarity panel appears below the annotations section, separated by a border
  </action>
  <verify>
    1. Open a dataset with embeddings generated
    2. Click any thumbnail to open the SampleModal
    3. Click "Find Similar" button in the metadata section
    4. Verify similar images load as a 4-column thumbnail grid with percentage scores
    5. Click a similar image thumbnail -- verify the modal navigates to that sample
    6. Click "Hide Similar" -- verify the panel collapses
    7. TypeScript check: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
    "Find Similar" button appears in the SampleModal. Clicking it shows a grid of visually similar images with cosine similarity scores. Clicking a similar image navigates the modal to that sample. No TypeScript errors.
  </done>
</task>

</tasks>

<verification>
1. Backend: Similarity search endpoint returns ranked results with scores. Qdrant collection creates lazily on first query (check data/qdrant/ directory). Results exclude the query sample.
2. Frontend: "Find Similar" button toggles similarity panel in SampleModal. Thumbnails load with score badges. Clicking navigates to that sample.
3. Edge cases: Sample with no embeddings returns empty results (not error). Dataset with no embeddings shows "Generate embeddings first" message.
4. Qdrant lifecycle: After first similarity query, subsequent queries are fast (collection already exists). If embeddings were re-generated, the collection would need invalidation (this is handled by invalidate_collection but the trigger from the embedding router is a future enhancement).
5. TypeScript: `cd frontend && npx tsc --noEmit` passes.
</verification>

<success_criteria>
- Qdrant installs and initializes in local disk mode without Docker
- Similarity search endpoint returns results with cosine similarity scores in 0-1 range
- "Find Similar" button visible in SampleModal for any sample
- Similar images display as thumbnail grid with percentage scores
- Clicking a similar image navigates to that sample in the modal
- Lazy collection sync works (first query triggers DuckDB -> Qdrant sync)
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-analysis-similarity/06-02-SUMMARY.md`
</output>
