---
phase: 12-interactive-viz-discovery
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - app/services/similarity_service.py
  - app/routers/similarity.py
  - app/models/similarity.py
  - frontend/src/hooks/use-near-duplicates.ts
  - frontend/src/components/stats/near-duplicates-panel.tsx
  - frontend/src/components/stats/stats-dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "User can trigger near-duplicate detection from the statistics dashboard"
    - "Detection progress is displayed via a progress bar while scanning"
    - "Duplicate groups are displayed as clickable rows showing group size and thumbnail previews"
    - "Clicking a duplicate group filters the grid to show only the samples in that group"
  artifacts:
    - path: "app/services/similarity_service.py"
      provides: "find_near_duplicates method with union-find grouping + progress tracking"
      contains: "def find_near_duplicates"
    - path: "app/routers/similarity.py"
      provides: "POST trigger endpoint + GET SSE progress endpoint for near-duplicate detection"
      contains: "near-duplicates"
    - path: "frontend/src/hooks/use-near-duplicates.ts"
      provides: "Hook for triggering detection, tracking SSE progress, and fetching results"
      exports: ["useNearDuplicates"]
    - path: "frontend/src/components/stats/near-duplicates-panel.tsx"
      provides: "UI panel showing duplicate groups with click-to-filter"
      exports: ["NearDuplicatesPanel"]
  key_links:
    - from: "frontend/src/components/stats/near-duplicates-panel.tsx"
      to: "frontend/src/hooks/use-near-duplicates.ts"
      via: "useNearDuplicates hook for trigger + results"
      pattern: "useNearDuplicates"
    - from: "frontend/src/hooks/use-near-duplicates.ts"
      to: "app/routers/similarity.py"
      via: "POST trigger + EventSource SSE progress + GET results"
      pattern: "near-duplicates"
    - from: "frontend/src/components/stats/near-duplicates-panel.tsx"
      to: "frontend/src/stores/filter-store.ts"
      via: "setSampleIdFilter on group click"
      pattern: "setSampleIdFilter"
---

<objective>
Add near-duplicate detection using Qdrant pairwise similarity search with union-find grouping, exposed as an async operation with SSE progress.

Purpose: Implements TRIAGE-05 -- users can discover visually similar or duplicated images in their dataset, which is critical for data quality (training on duplicates inflates metrics and causes data leakage across splits).

Output: A "Near Duplicates" sub-tab on the statistics dashboard where users can trigger detection, see progress, browse duplicate groups, and click any group to view those samples in the grid.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-interactive-viz-discovery/12-RESEARCH.md
@.planning/phases/12-interactive-viz-discovery/12-01-SUMMARY.md

@app/services/similarity_service.py
@app/routers/similarity.py
@app/routers/embeddings.py
@app/models/similarity.py
@app/dependencies.py
@frontend/src/stores/filter-store.ts
@frontend/src/stores/ui-store.ts
@frontend/src/components/stats/stats-dashboard.tsx
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend near-duplicate detection with SSE progress</name>
  <files>
    app/services/similarity_service.py
    app/routers/similarity.py
    app/models/similarity.py
  </files>
  <action>
    1. In `app/models/similarity.py`, add models:
       ```python
       class NearDuplicateGroup(BaseModel):
           sample_ids: list[str]
           size: int

       class NearDuplicateResponse(BaseModel):
           groups: list[NearDuplicateGroup]
           total_groups: int
           total_duplicates: int  # total samples across all groups
           threshold: float

       class NearDuplicateProgress(BaseModel):
           status: str  # "scanning" | "grouping" | "complete" | "error"
           progress: float  # 0.0 to 1.0
           scanned: int
           total: int
           groups_found: int
           message: str
       ```

    2. In `app/services/similarity_service.py`, add to the `SimilarityService` class:

       a. Progress tracking state (same pattern as EmbeddingService):
          ```python
          def __init__(self, ...):
              ...
              self._near_dupe_progress: dict[str, NearDuplicateProgress] = {}
              self._near_dupe_results: dict[str, NearDuplicateResponse] = {}
          ```

       b. Union-find helper functions (module-level, not methods):
          ```python
          def _find(parent: dict[str, str], x: str) -> str:
              while parent.get(x, x) != x:
                  parent[x] = parent.get(parent[x], parent[x])  # path compression
                  x = parent[x]
              return x

          def _union(parent: dict[str, str], a: str, b: str) -> None:
              ra, rb = _find(parent, a), _find(parent, b)
              if ra != rb:
                  parent[ra] = rb
          ```

       c. `find_near_duplicates` method:
          ```python
          def find_near_duplicates(
              self, dataset_id: str, threshold: float = 0.95, limit_per_query: int = 10
          ) -> NearDuplicateResponse:
          ```
          Algorithm:
          - Set initial progress: status="scanning", progress=0.0
          - Call `self.ensure_collection(dataset_id)` to ensure Qdrant has data.
          - Scroll ALL points from the collection using `self.client.scroll()` in a loop (batch_size=500, with_vectors=True, with_payload=True). Collect all points.
          - Set total = len(all_points).
          - For each point (with index i for progress):
            - Query `self.client.query_points(collection_name, query=point.vector, score_threshold=threshold, limit=limit_per_query, with_payload=True)`.
            - For each result where result.payload["sample_id"] != point.payload["sample_id"]: call `_union(parent, sid, r_sid)`.
            - Update progress: status="scanning", progress=i/total, scanned=i, total=total.
          - After all scanned: status="grouping", progress=1.0.
          - Group by root using `_find`:
            ```python
            groups: dict[str, list[str]] = defaultdict(list)
            all_sids = set()
            for point in all_points:
                sid = point.payload["sample_id"]
                if sid in parent or sid in [p.payload["sample_id"] for p in all_points if _find(parent, p.payload["sample_id"]) != p.payload["sample_id"]]:
                    # Only include samples that appear in the parent dict (were involved in a union)
                    root = _find(parent, sid)
                    groups[root].append(sid)
            ```
            Actually simpler: iterate all sample_ids that exist in `parent` dict, group by `_find(parent, sid)`. Filter to groups of size >= 2.
          - Build NearDuplicateResponse with groups sorted by size descending.
          - Cache result in `self._near_dupe_results[dataset_id]`.
          - Set progress: status="complete".
          - Return the response.

       d. Progress/result accessors:
          ```python
          def get_near_dupe_progress(self, dataset_id: str) -> NearDuplicateProgress:
              return self._near_dupe_progress.get(dataset_id, NearDuplicateProgress(
                  status="idle", progress=0, scanned=0, total=0, groups_found=0, message="Not started"
              ))

          def get_near_dupe_results(self, dataset_id: str) -> NearDuplicateResponse | None:
              return self._near_dupe_results.get(dataset_id)

          def is_near_dupe_running(self, dataset_id: str) -> bool:
              p = self._near_dupe_progress.get(dataset_id)
              return p is not None and p.status in ("scanning", "grouping")
          ```

    3. In `app/routers/similarity.py`, add three endpoints:

       a. `POST /datasets/{dataset_id}/near-duplicates/detect` -- triggers background detection:
          - Accept optional `threshold` query param (default 0.95, range 0.80-0.99).
          - Check `similarity_service.is_near_dupe_running(dataset_id)` -- if true, return 409.
          - Verify dataset exists.
          - Use `BackgroundTasks` to run `similarity_service.find_near_duplicates(dataset_id, threshold)`.
          - Return 202 with `{"status": "started", "message": "Near-duplicate detection started"}`.

       b. `GET /datasets/{dataset_id}/near-duplicates/progress` -- SSE stream:
          - Follow exact same pattern as `embedding_progress` in embeddings.py.
          - Use `EventSourceResponse` with async generator.
          - Yield `similarity_service.get_near_dupe_progress(dataset_id)` every 0.5s.
          - Stop when status is "complete" or "error".

       c. `GET /datasets/{dataset_id}/near-duplicates` -- returns cached results:
          - Return `similarity_service.get_near_dupe_results(dataset_id)`.
          - If no results cached, return 404 with "No near-duplicate results. Run detection first."

       Import `asyncio`, `json`, `BackgroundTasks` and `EventSourceResponse` (from `sse_starlette.sse`).
  </action>
  <verify>
    Backend starts: `python -c "from app.routers.similarity import router; print('OK')"` succeeds.
    New endpoints registered: POST /near-duplicates/detect, GET /near-duplicates/progress, GET /near-duplicates.
    Union-find functions are correct: `_find` with path compression, `_union` merges roots.
  </verify>
  <done>
    Backend has near-duplicate detection via Qdrant pairwise search with union-find grouping. Runs as background task with SSE progress stream. Results cached in memory and served via GET endpoint. Supports configurable similarity threshold.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend near-duplicates panel with detection trigger and group browsing</name>
  <files>
    frontend/src/hooks/use-near-duplicates.ts
    frontend/src/components/stats/near-duplicates-panel.tsx
    frontend/src/components/stats/stats-dashboard.tsx
  </files>
  <action>
    1. Create `frontend/src/hooks/use-near-duplicates.ts`:
       - Types:
         ```typescript
         interface NearDuplicateGroup { sample_ids: string[]; size: number; }
         interface NearDuplicateResponse { groups: NearDuplicateGroup[]; total_groups: number; total_duplicates: number; threshold: number; }
         interface NearDuplicateProgress { status: string; progress: number; scanned: number; total: number; groups_found: number; message: string; }
         ```

       - `triggerDetection(datasetId: string, threshold?: number)`: POST to `/datasets/{datasetId}/near-duplicates/detect?threshold={threshold}` via `apiFetch`. Returns void. Fire and forget.

       - `useNearDuplicateProgress(datasetId: string, enabled: boolean)`: Custom hook that:
         - Uses `useState` for progress state.
         - When `enabled` is true, opens an `EventSource` to `/api/datasets/${datasetId}/near-duplicates/progress`.
         - On "progress" event: parse JSON, update state.
         - On complete: close EventSource, set enabled to false (or let caller handle).
         - Clean up EventSource on unmount.
         - Return `{ progress, isRunning }`.

       - `useNearDuplicateResults(datasetId: string, enabled: boolean)`: TanStack Query hook:
         - `queryKey: ["near-duplicates", datasetId]`
         - `queryFn`: GET `/datasets/${datasetId}/near-duplicates` via `apiFetch`.
         - `enabled`: only when explicitly enabled (after detection completes).
         - Returns `NearDuplicateResponse | undefined`.

       Export all three.

    2. Create `frontend/src/components/stats/near-duplicates-panel.tsx`:
       - Props: `{ datasetId: string }`
       - State:
         - `threshold` slider (0.80 to 0.99, default 0.95, step 0.01)
         - `isDetecting` boolean
         - `resultsReady` boolean (set true when detection completes)

       - Layout:
         a. Header: "Near Duplicates" with description text.
         b. Controls row: threshold slider + "Detect Duplicates" button.
         c. Progress bar (shown during detection): uses `useNearDuplicateProgress`.
            - Show "Scanning {scanned}/{total} embeddings..." with a div-based progress bar.
            - Width = `progress * 100%`.
         d. Results (shown when results are available): uses `useNearDuplicateResults`.
            - Summary: "{total_groups} duplicate groups found ({total_duplicates} images)"
            - List of groups, each as a clickable card:
              - Show "Group {i+1}: {size} images"
              - On click: call `useFilterStore.getState().setSampleIdFilter(group.sample_ids)` then `useUIStore.getState().setActiveTab("grid")`.
              - Style: rounded border, hover:bg-zinc-50 dark:hover:bg-zinc-800, cursor-pointer.
            - If 0 groups: show "No near-duplicates found at threshold {threshold}. Try lowering the threshold."

       - Flow:
         1. User adjusts threshold slider.
         2. User clicks "Detect Duplicates".
         3. Call `triggerDetection(datasetId, threshold)`.
         4. Set `isDetecting = true` to enable progress hook.
         5. Progress bar fills as SSE events arrive.
         6. When progress.status === "complete": set `isDetecting = false`, `resultsReady = true`.
         7. Results hook fetches and displays groups.
         8. User clicks a group -> grid filters to those samples.

    3. In `stats-dashboard.tsx`:
       - Add "Near Duplicates" as a new sub-tab option. Add to `SubTab` type: `"near_duplicates"`.
       - Add a tab button for it (between "Worst Images" and "Intelligence", or at the end before Intelligence).
       - This tab should NOT require predictions (near-dupes work on embeddings, not predictions). So do NOT disable it when `!hasPredictions`. Instead, it should be available whenever embeddings exist. For simplicity, always show it (it will show a helpful message if no embeddings exist -- handle in the panel itself or just let it fail gracefully).
       - Render `<NearDuplicatesPanel datasetId={datasetId} />` when the sub-tab is active.
       - Import `NearDuplicatesPanel` at the top.

    Note: The EventSource URL should use the API base path. Check how other SSE connections are established in the codebase (look at embedding generation progress in the frontend for the URL pattern). The EventSource URL should be something like `${process.env.NEXT_PUBLIC_API_URL}/datasets/${datasetId}/near-duplicates/progress` or `/api/datasets/${datasetId}/near-duplicates/progress` depending on the proxy setup. Match whatever pattern the embedding progress SSE uses.
  </action>
  <verify>
    TypeScript compiles: `cd frontend && npx tsc --noEmit` passes.
    stats-dashboard.tsx has "near_duplicates" in SubTab type.
    NearDuplicatesPanel renders threshold slider and detect button.
    use-near-duplicates.ts exports triggerDetection, useNearDuplicateProgress, useNearDuplicateResults.
  </verify>
  <done>
    Users can trigger near-duplicate detection from a new sub-tab, watch progress via SSE, browse resulting groups sorted by size, and click any group to filter the grid to those samples. Threshold is configurable via slider.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. Backend starts without import errors
3. POST /datasets/{id}/near-duplicates/detect returns 202
4. GET /datasets/{id}/near-duplicates/progress streams SSE events
5. GET /datasets/{id}/near-duplicates returns cached results
6. "Near Duplicates" sub-tab appears on statistics dashboard
7. Clicking a duplicate group calls setSampleIdFilter and switches to grid
</verification>

<success_criteria>
- TRIAGE-05: User can trigger near-duplicate detection and browse groups of visually similar images
- Detection runs asynchronously with real-time progress via SSE
- Groups are clickable and filter the grid via sampleIdFilter
- Threshold is configurable (0.80-0.99) via slider
- Empty results show helpful message suggesting lower threshold
</success_criteria>

<output>
After completion, create `.planning/phases/12-interactive-viz-discovery/12-03-SUMMARY.md`
</output>
