---
phase: 02-visual-grid
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/next.config.ts
  - frontend/src/app/layout.tsx
  - frontend/src/app/page.tsx
  - frontend/src/app/datasets/[datasetId]/page.tsx
  - frontend/src/components/providers/query-provider.tsx
  - frontend/src/components/grid/image-grid.tsx
  - frontend/src/components/grid/grid-cell.tsx
  - frontend/src/hooks/use-samples.ts
  - frontend/src/lib/api.ts
  - frontend/src/lib/constants.ts
  - frontend/src/stores/ui-store.ts
  - frontend/src/types/sample.ts
  - frontend/src/types/dataset.ts
  - frontend/src/types/annotation.ts
autonomous: true

must_haves:
  truths:
    - "Next.js app boots and renders at localhost:3000"
    - "User can navigate to /datasets/[id] and see a grid of thumbnail images"
    - "Scrolling down loads more thumbnails automatically (infinite scroll)"
    - "Grid virtualizes rows so only visible thumbnails are in the DOM"
  artifacts:
    - path: "frontend/src/components/grid/image-grid.tsx"
      provides: "Virtualized grid with infinite scroll"
      min_lines: 60
    - path: "frontend/src/components/grid/grid-cell.tsx"
      provides: "Single thumbnail cell"
      min_lines: 20
    - path: "frontend/src/hooks/use-samples.ts"
      provides: "useInfiniteQuery hook for paginated sample fetching"
      min_lines: 15
    - path: "frontend/src/lib/api.ts"
      provides: "API fetch wrapper and URL helpers"
      exports: ["apiFetch", "thumbnailUrl", "fullImageUrl"]
    - path: "frontend/src/types/sample.ts"
      provides: "TypeScript types matching backend SampleResponse and PaginatedSamples"
      contains: "PaginatedSamples"
  key_links:
    - from: "frontend/src/components/grid/image-grid.tsx"
      to: "frontend/src/hooks/use-samples.ts"
      via: "useSamples hook providing paginated data"
      pattern: "useSamples"
    - from: "frontend/src/hooks/use-samples.ts"
      to: "http://localhost:8000/samples"
      via: "apiFetch calling backend API"
      pattern: "apiFetch.*samples"
    - from: "frontend/src/components/grid/image-grid.tsx"
      to: "@tanstack/react-virtual"
      via: "useVirtualizer for row virtualization"
      pattern: "useVirtualizer"
    - from: "frontend/src/components/grid/grid-cell.tsx"
      to: "http://localhost:8000/images"
      via: "thumbnailUrl helper for img src"
      pattern: "thumbnailUrl"
---

<objective>
Scaffold the Next.js frontend application and build the virtualized image grid with infinite scroll that fetches paginated thumbnails from the Phase 1 backend API.

Purpose: This is the foundation of the entire frontend. The grid is the primary interface -- users browse 100K+ images by scrolling. Virtualization ensures only visible rows exist in the DOM, and infinite scroll fetches pages on demand via TanStack Query.

Output: A working Next.js app at localhost:3000 with a virtualized grid that loads and displays image thumbnails from the backend, with automatic page fetching on scroll.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-visual-grid/02-RESEARCH.md
@app/models/sample.py
@app/models/annotation.py
@app/models/dataset.py
@app/routers/samples.py
@app/routers/images.py
@app/routers/datasets.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Next.js app with dependencies, types, API lib, providers, and store</name>
  <files>
    frontend/package.json
    frontend/next.config.ts
    frontend/src/app/layout.tsx
    frontend/src/app/page.tsx
    frontend/src/components/providers/query-provider.tsx
    frontend/src/lib/api.ts
    frontend/src/lib/constants.ts
    frontend/src/stores/ui-store.ts
    frontend/src/types/sample.ts
    frontend/src/types/dataset.ts
    frontend/src/types/annotation.ts
  </files>
  <action>
    1. Create the Next.js app using create-next-app:
       ```bash
       cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor
       npx create-next-app@latest frontend --app --typescript --tailwind --eslint --turbopack --import-alias "@/*" --yes
       ```

    2. Install Phase 2 dependencies:
       ```bash
       cd frontend
       npm install @tanstack/react-query @tanstack/react-virtual zustand color-hash clsx
       npm install -D @tanstack/react-query-devtools @types/color-hash
       ```

    3. Create TypeScript types that mirror the backend Pydantic models exactly:

       `src/types/sample.ts`:
       - `Sample` interface: id (string), dataset_id (string), file_name (string), width (number), height (number), thumbnail_path (string | null), split (string | null)
       - `PaginatedSamples` interface: items (Sample[]), total (number), offset (number), limit (number)

       `src/types/dataset.ts`:
       - `Dataset` interface: id (string), name (string), format (string), source_path (string), image_dir (string), image_count (number), annotation_count (number), category_count (number), created_at (string)
       - `DatasetList` interface: datasets (Dataset[])

       `src/types/annotation.ts`:
       - `Annotation` interface: id (string), dataset_id (string), sample_id (string), category_name (string), bbox_x (number), bbox_y (number), bbox_w (number), bbox_h (number), area (number), is_crowd (boolean), source (string), confidence (number | null)

    4. Create `src/lib/constants.ts`:
       - `API_BASE`: reads from `process.env.NEXT_PUBLIC_API_URL` with fallback to `'http://localhost:8000'`
       - `PAGE_SIZE`: 50 (matches backend default limit)
       - `DEFAULT_COLUMNS`: 6
       - `MIN_CELL_WIDTH`: 200 (px)
       - `MAX_COLUMNS`: 10
       - `MIN_COLUMNS`: 3

    5. Create `src/lib/api.ts`:
       - `apiFetch<T>(path: string): Promise<T>` -- fetches from `${API_BASE}${path}`, throws on non-OK response
       - `thumbnailUrl(datasetId: string, sampleId: string, size = 'medium'): string` -- returns URL string (no fetch)
       - `fullImageUrl(datasetId: string, sampleId: string): string` -- returns URL with size=original

    6. Create `src/components/providers/query-provider.tsx` ('use client'):
       - Creates QueryClient with `useState(() => new QueryClient({...}))` pattern
       - Default staleTime: 5 * 60 * 1000 (5 min) -- dataset contents don't change during session
       - Default gcTime: 30 * 60 * 1000 (30 min)
       - refetchOnWindowFocus: false
       - Include ReactQueryDevtools (initialIsOpen: false)

    7. Update `src/app/layout.tsx`:
       - Wrap children with QueryProvider
       - Keep metadata title as "VisionLens"

    8. Create `src/stores/ui-store.ts`:
       - Zustand store with simple `create()` pattern (not per-request -- grid is fully client-rendered)
       - State: selectedSampleId (string | null), isDetailModalOpen (boolean), columnsPerRow (number, default 6)
       - Actions: openDetailModal(sampleId), closeDetailModal(), setColumnsPerRow(cols)

    9. Update `src/app/page.tsx`:
       - Simple home page that fetches GET /datasets and displays a list
       - Each dataset links to `/datasets/${dataset.id}`
       - Show dataset name, image count, annotation count

    10. Update `next.config.ts`:
        - Add `images.remotePatterns` for localhost:8000 (or keep images unoptimized since we serve our own WebP thumbnails)
        - No other config needed -- Turbopack is default in Next.js 16

    AVOID:
    - Do NOT use `middleware.ts` -- it's deprecated in Next.js 16 (renamed to `proxy.ts`), and we don't need it
    - Do NOT use blob URLs for images -- rely on browser HTTP cache for thumbnail URLs
    - Do NOT put server data (samples, datasets) in Zustand -- that belongs in TanStack Query
  </action>
  <verify>
    ```bash
    cd frontend && npm run build
    ```
    Build succeeds with no TypeScript errors. Run `npm run dev` and verify localhost:3000 loads without errors in browser console.
  </verify>
  <done>
    Next.js app boots at localhost:3000, shows a dataset list page, has all types/lib/providers/store created, no TypeScript errors on build.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build virtualized image grid with infinite scroll</name>
  <files>
    frontend/src/app/datasets/[datasetId]/page.tsx
    frontend/src/components/grid/image-grid.tsx
    frontend/src/components/grid/grid-cell.tsx
    frontend/src/hooks/use-samples.ts
  </files>
  <action>
    1. Create `src/hooks/use-samples.ts`:
       - Export `useSamples(datasetId: string)` that wraps `useInfiniteQuery`
       - queryKey: ['samples', datasetId]
       - queryFn: calls `apiFetch<PaginatedSamples>(`/samples?dataset_id=${datasetId}&offset=${pageParam}&limit=${PAGE_SIZE}`)`
       - getNextPageParam: compute nextOffset = lastPage.offset + lastPage.limit, return undefined if >= lastPage.total
       - initialPageParam: 0

    2. Create `src/components/grid/image-grid.tsx` ('use client'):
       - Accept `datasetId` prop
       - Use `useSamples(datasetId)` for data
       - Flatten pages: `const allSamples = data?.pages.flatMap(p => p.items) ?? []`
       - Read `columnsPerRow` from `useUIStore`
       - Compute `rowCount = Math.ceil(allSamples.length / columnsPerRow)`
       - Use `useVirtualizer` for ROW virtualization only (columns handled by CSS grid):
         - count: hasNextPage ? rowCount + 1 : rowCount (extra row triggers fetch)
         - getScrollElement: () => parentRef.current
         - estimateSize: () => cellSize (compute from container width / columnsPerRow)
         - overscan: 3
       - Add `useEffect` to trigger `fetchNextPage()` when last virtual item index >= rowCount - 1 and hasNextPage and !isFetchingNextPage
       - Render: scrollable container div (ref={parentRef}, h-screen overflow-auto) containing positioned virtual rows, each row is a CSS grid with `gridTemplateColumns: repeat(columnsPerRow, 1fr)` and gap
       - Each cell renders `<GridCell>` for the sample at index `rowIndex * columnsPerRow + colIndex`
       - Show loading skeleton for empty cells / loading state
       - Responsive columns: use a ResizeObserver on parentRef with 200ms debounce to compute `Math.floor(containerWidth / MIN_CELL_WIDTH)` clamped to [MIN_COLUMNS, MAX_COLUMNS], and call `setColumnsPerRow`

    3. Create `src/components/grid/grid-cell.tsx` ('use client'):
       - Accept `sample: Sample` and `datasetId: string` props
       - Render as a `<button>` (clickable for detail modal later) with:
         - `<img>` using `thumbnailUrl(datasetId, sample.id)` as src
         - loading="lazy", decoding="async" on the img
         - aspect-square, overflow-hidden, rounded, bg-gray-100 placeholder
         - hover:ring-2 hover:ring-blue-500 transition-shadow
       - onClick: call `useUIStore.openDetailModal(sample.id)` (wired but modal not built yet)
       - Show filename as a small label at bottom of cell

    4. Create `src/app/datasets/[datasetId]/page.tsx` ('use client'):
       - Extract `datasetId` from params
       - Render `<ImageGrid datasetId={datasetId} />`
       - Add a simple header showing dataset name (fetch via a simple useQuery for GET /datasets/{datasetId})

    AVOID:
    - Do NOT use a column virtualizer -- CSS grid handles columns. Only virtualize rows.
    - Do NOT use `allSamples.length` for virtualizer count when hasNextPage -- add +1 row to trigger prefetch
    - Do NOT set staleTime to 0 (causes refetch flicker on every re-render)
  </action>
  <verify>
    1. Start the backend: `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && uv run uvicorn app.main:app --reload`
    2. Ingest a test dataset if none exists
    3. Start frontend: `cd frontend && npm run dev`
    4. Navigate to localhost:3000, click a dataset
    5. Verify: grid of thumbnails loads, scrolling down loads more pages, browser DevTools Network tab shows paginated /samples requests
    6. `npm run build` succeeds with no errors
  </verify>
  <done>
    Virtualized grid renders at /datasets/[id], thumbnails load from backend, scrolling triggers infinite scroll pagination, only visible rows exist in DOM (verify via React DevTools or DOM inspector), responsive column count adjusts on window resize.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npm run build` -- zero TypeScript errors
2. Navigate to localhost:3000 -- dataset list renders
3. Click a dataset -- grid of thumbnails renders
4. Scroll down -- more thumbnails load (check Network tab for paginated /samples calls)
5. Inspect DOM -- only ~10-15 row divs exist regardless of total samples (virtualization working)
6. Resize browser window -- column count adjusts between 3-10
</verification>

<success_criteria>
- Next.js app builds and runs without errors
- Grid displays thumbnails fetched from backend API
- Infinite scroll loads additional pages on demand
- Row virtualization keeps DOM node count constant during scroll
- Responsive column count adapts to viewport width
</success_criteria>

<output>
After completion, create `.planning/phases/02-visual-grid/02-01-SUMMARY.md`
</output>
