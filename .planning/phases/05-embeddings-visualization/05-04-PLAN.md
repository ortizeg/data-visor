---
phase: 05-embeddings-visualization
plan: 04
type: execute
wave: 4
depends_on: ["05-03"]
files_modified:
  - frontend/src/components/embedding/lasso-overlay.tsx
  - frontend/src/components/embedding/embedding-scatter.tsx
  - frontend/src/components/embedding/embedding-panel.tsx
  - frontend/src/stores/embedding-store.ts
  - frontend/src/hooks/use-samples.ts
  - frontend/src/stores/filter-store.ts
  - app/routers/samples.py
  - app/services/filter_builder.py
autonomous: true

must_haves:
  truths:
    - "User can draw a freehand lasso polygon on the scatter plot to select points"
    - "Selected points are visually highlighted in the scatter plot"
    - "After lasso selection, switching to Grid tab shows only the lasso-selected images"
    - "User can clear the lasso selection to return to the full grid"
    - "Lasso selection works with bounding-box pre-filter for performance on large datasets"
    - "Backend accepts sample_ids filter param to return only specific samples"
  artifacts:
    - path: "frontend/src/components/embedding/lasso-overlay.tsx"
      provides: "SVG overlay for freehand polygon drawing on top of deck.gl"
      contains: "polyline"
    - path: "frontend/src/stores/embedding-store.ts"
      provides: "Zustand store for lasso-selected sample IDs"
      exports: ["useEmbeddingStore", "useLassoSelectedIds"]
    - path: "app/routers/samples.py"
      provides: "sample_ids query param on GET /samples for lasso filtering"
      contains: "sample_ids"
    - path: "app/services/filter_builder.py"
      provides: "add_sample_ids method on SampleFilterBuilder"
      contains: "add_sample_ids"
  key_links:
    - from: "frontend/src/components/embedding/lasso-overlay.tsx"
      to: "robust-point-in-polygon"
      via: "classifyPoint for each scatter point against lasso polygon"
      pattern: "classifyPoint"
    - from: "frontend/src/components/embedding/lasso-overlay.tsx"
      to: "frontend/src/stores/embedding-store.ts"
      via: "setLassoSelectedIds after point-in-polygon testing"
      pattern: "setLassoSelectedIds"
    - from: "frontend/src/hooks/use-samples.ts"
      to: "frontend/src/stores/embedding-store.ts"
      via: "Include lassoSelectedIds in query params when present"
      pattern: "lassoSelectedIds"
    - from: "frontend/src/hooks/use-samples.ts"
      to: "app/routers/samples.py"
      via: "Pass sample_ids param in GET /samples request"
      pattern: "sample_ids"
---

<objective>
Implement lasso selection on the embedding scatter plot that cross-filters the image grid, so users can draw a freehand polygon around cluster regions and see only those images in the grid.

Purpose: Lasso selection is the key interaction pattern that connects embedding visualization to the grid browse experience. Without it, the scatter plot is a nice picture but not a workflow tool. This plan closes the loop from "see clusters" to "inspect specific images."

Output: An SVG lasso overlay with robust point-in-polygon testing, a Zustand embedding store for selection state, backend sample_ids filtering support, and cross-filter wiring between the scatter plot and grid.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-embeddings-visualization/05-RESEARCH.md
@.planning/phases/05-embeddings-visualization/05-03-SUMMARY.md

Source files to reference (read before implementing):
@frontend/src/components/embedding/embedding-scatter.tsx -- Scatter plot to overlay lasso on
@frontend/src/components/embedding/embedding-panel.tsx -- Container to wire lasso into
@frontend/src/hooks/use-samples.ts -- Samples query to add sample_ids param
@frontend/src/hooks/use-embeddings.ts -- useEmbeddingCoordinates for point data
@frontend/src/stores/filter-store.ts -- Pattern for Zustand store with atomic selectors
@frontend/src/stores/ui-store.ts -- Existing Zustand store pattern
@app/routers/samples.py -- Samples endpoint to add sample_ids param
@app/services/filter_builder.py -- SampleFilterBuilder to extend with add_sample_ids
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend sample_ids filter and Zustand embedding store</name>
  <files>
    app/services/filter_builder.py
    app/routers/samples.py
    frontend/src/stores/embedding-store.ts
  </files>
  <action>
    **1. Add `add_sample_ids` to `app/services/filter_builder.py`:**
    Add a new method to `SampleFilterBuilder`:
    ```python
    def add_sample_ids(self, sample_ids: list[str] | None) -> "SampleFilterBuilder":
        """Filter by explicit sample ID list (for lasso selection). Skipped if None."""
        if sample_ids is not None and len(sample_ids) > 0:
            placeholders = ", ".join(["?"] * len(sample_ids))
            self.conditions.append(f"s.id IN ({placeholders})")
            self.params.extend(sample_ids)
        return self
    ```

    **2. Add `sample_ids` query param to `app/routers/samples.py` `list_samples()`:**
    - Add new Query parameter: `sample_ids: str | None = Query(None, description="Comma-separated sample IDs (for lasso selection, max 5000)")`
    - Parse: `sample_id_list = [sid.strip() for sid in sample_ids.split(",") if sid.strip()] if sample_ids else None`
    - Add validation: if `sample_id_list` and `len(sample_id_list) > 5000`, raise HTTPException(400, "Maximum 5000 sample_ids per request")
    - Add to builder chain: `.add_sample_ids(sample_id_list)` (after `.add_tags(tag_list)`)
    - This lets the frontend send lasso-selected sample IDs to filter the grid
    - Cap at 5000 (not 200 like batch-annotations) because lasso selection can span large clusters

    **3. Create `frontend/src/stores/embedding-store.ts`:**
    Zustand store for embedding-related state (lasso selection):
    ```typescript
    import { create } from "zustand";

    interface EmbeddingState {
      /** Sample IDs selected via lasso. null = no lasso active (show all). */
      lassoSelectedIds: string[] | null;
      /** Set lasso-selected IDs (after point-in-polygon testing). */
      setLassoSelectedIds: (ids: string[] | null) => void;
      /** Clear lasso selection. */
      clearLasso: () => void;
    }

    export const useEmbeddingStore = create<EmbeddingState>((set) => ({
      lassoSelectedIds: null,
      setLassoSelectedIds: (ids) => set({ lassoSelectedIds: ids }),
      clearLasso: () => set({ lassoSelectedIds: null }),
    }));

    // Atomic selectors
    export const useLassoSelectedIds = () =>
      useEmbeddingStore((s) => s.lassoSelectedIds);
    ```
  </action>
  <verify>
    - `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && python -m pytest tests/ -v --timeout=60` -- all existing tests pass
    - `python -c "from app.services.filter_builder import SampleFilterBuilder; b = SampleFilterBuilder(); r = b.add_dataset('ds1').add_sample_ids(['s1','s2']).build(); print(r.where_clause, r.params)"` -- shows `s.dataset_id = ? AND s.id IN (?, ?)` with params `['ds1', 's1', 's2']`
    - `cd frontend && npx tsc --noEmit` -- no TypeScript errors in new store
  </verify>
  <done>
    Backend supports sample_ids query parameter for lasso-to-grid filtering. SampleFilterBuilder extended with add_sample_ids. Zustand embedding store manages lasso selection state with null semantics (null = no filter, array = filtered).
  </done>
</task>

<task type="auto">
  <name>Task 2: Lasso overlay component and cross-filter wiring</name>
  <files>
    frontend/src/components/embedding/lasso-overlay.tsx
    frontend/src/components/embedding/embedding-scatter.tsx
    frontend/src/components/embedding/embedding-panel.tsx
    frontend/src/hooks/use-samples.ts
  </files>
  <action>
    **1. Create `frontend/src/components/embedding/lasso-overlay.tsx`:**
    SVG overlay for freehand lasso drawing:
    ```typescript
    interface LassoOverlayProps {
      /** All scatter points (for hit testing) */
      points: EmbeddingPoint[];
      /** Current deck.gl view state (for coordinate projection) */
      deckRef: React.RefObject<DeckGL>;
      /** Callback when lasso selection completes */
      onSelect: (selectedIds: string[]) => void;
      /** Whether lasso tool is active */
      active: boolean;
    }
    ```
    Implementation:
    - Render an absolutely-positioned SVG covering the parent container: `className="absolute inset-0 z-10"`, `style={{ pointerEvents: active ? "all" : "none", cursor: active ? "crosshair" : "default" }}`
    - State: `isDrawing: boolean`, `path: [number, number][]` (screen coordinates)
    - `onMouseDown`: start drawing, record first point `[e.clientX - rect.left, e.clientY - rect.top]` (relative to SVG container, not viewport)
    - `onMouseMove`: if drawing, append point to path. Throttle to every 3rd event for performance.
    - `onMouseUp`: stop drawing. If path.length < 3, return (not enough for a polygon).
      a. Compute bounding box of lasso polygon (min/max x, min/max y in screen coords) -- cheap pre-filter
      b. For each scatter point, use `deckRef.current.deck.getViewports()[0].project([p.x, p.y])` to get screen coordinates. If no deck ref or viewport available, fall back to iterating all points.
      c. First filter points whose screen coords fall within the bounding box
      d. Then test each bbox-filtered point with `classifyPoint(path, [screenX, screenY])`. `classifyPoint` returns -1 (inside), 0 (boundary), 1 (outside). Select points where result <= 0.
      e. Call `onSelect(selectedIds)` with the array of matching sample IDs
    - Render the lasso polygon: `<polyline points={pathStr} fill="rgba(99,102,241,0.15)" stroke="#6366f1" strokeWidth={2} strokeDasharray="4,4" />`
    - Import `classifyPoint` from `robust-point-in-polygon`

    **Performance optimization (Pitfall 5 from research):**
    - Bounding-box pre-filter reduces O(n*m) to O(k*m) where k << n for typical lasso sizes
    - For datasets with >10k points, consider using requestIdleCallback for the hit testing. For now, the bbox pre-filter should be sufficient for the target 100k scale.

    **2. Update `frontend/src/components/embedding/embedding-scatter.tsx`:**
    - Accept `selectedIds: string[] | null` prop
    - When `selectedIds` is not null, update the ScatterplotLayer's `getFillColor` to differentiate selected vs unselected points:
      - Selected: `[99, 102, 241, 230]` (indigo, opaque)
      - Unselected: `[180, 180, 180, 80]` (gray, transparent)
    - Use a `Set` for O(1) lookup: `const selectedSet = useMemo(() => selectedIds ? new Set(selectedIds) : null, [selectedIds])`
    - `getFillColor: (d) => selectedSet === null ? [100, 120, 220, 200] : selectedSet.has(d.sampleId) ? [99, 102, 241, 230] : [180, 180, 180, 80]`
    - Expose a `ref` (via forwardRef or a deckRef prop) so the lasso overlay can access `deck.getViewports()[0].project()`

    **3. Update `frontend/src/components/embedding/embedding-panel.tsx`:**
    - Import `useEmbeddingStore` and `LassoOverlay`
    - Add a "Lasso" toggle button in the panel toolbar (above the scatter plot). When active, the lasso overlay captures mouse events.
    - Add a "Clear Selection" button that appears when `lassoSelectedIds !== null`. On click: `clearLasso()`.
    - Show selected count badge: e.g., "42 selected" next to the clear button
    - Wire `LassoOverlay onSelect` -> `setLassoSelectedIds(ids)` from embedding store
    - Pass `lassoSelectedIds` to `EmbeddingScatter` for visual highlighting
    - Wire the `deckRef` through to the lasso overlay for coordinate projection

    **4. Update `frontend/src/hooks/use-samples.ts`:**
    - Import `useEmbeddingStore` (specifically `useLassoSelectedIds`)
    - Read `lassoSelectedIds` from the embedding store
    - Include in queryKey: add `lassoSelectedIds` to the filters object (or as a separate key element). When lassoSelectedIds changes, TanStack Query auto-refetches.
    - In the queryFn: if `lassoSelectedIds` is not null and length > 0, add `sample_ids` param: `params.set("sample_ids", lassoSelectedIds.join(","))`
    - If lassoSelectedIds is null, don't set sample_ids (show all samples)
    - **Important:** Cap at 5000 IDs on the client side to match backend limit. If lasso selects more than 5000, truncate with a warning (this would be extremely unusual).
  </action>
  <verify>
    - `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor/frontend && npx tsc --noEmit` -- no TypeScript errors
    - `npm run build` -- build succeeds
    - Verify lasso-overlay.tsx imports robust-point-in-polygon: check source for `classifyPoint`
    - Verify use-samples.ts reads from embedding store: check source for `lassoSelectedIds`
    - `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && python -m pytest tests/ -v` -- all backend tests pass
  </verify>
  <done>
    SVG lasso overlay draws freehand polygons over the scatter plot. Point-in-polygon testing with robust-point-in-polygon classifies selected points (with bbox pre-filter for performance). Selected IDs flow to Zustand embedding store, which feeds into useSamples queryKey, triggering a refetch with sample_ids param. Grid view shows only lasso-selected images. Visual highlighting differentiates selected vs unselected points in the scatter plot. Clear button resets to full grid.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` -- no TypeScript errors
2. `npm run build` -- build succeeds
3. `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && python -m pytest tests/ -v` -- all backend tests pass
4. Verify backend: `python -c "from app.services.filter_builder import SampleFilterBuilder; b = SampleFilterBuilder(); r = b.add_dataset('ds1').add_sample_ids(['s1']).build(); print(r.where_clause)"` shows sample_ids filter
5. Verify cross-filter wiring: use-samples.ts includes lassoSelectedIds in query, samples.py accepts sample_ids param
</verification>

<success_criteria>
- Lasso tool draws freehand polygon on SVG overlay
- Point-in-polygon testing correctly identifies points inside lasso using robust-point-in-polygon
- Selected sample IDs stored in Zustand embedding store
- Grid tab shows only lasso-selected samples when selection active
- Clear button resets selection and restores full grid
- Backend sample_ids param works with existing filter chain (category, split, search, tags all compose)
- Performance acceptable for 10k+ points (bbox pre-filter reduces hit testing)
- All tests pass, no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-embeddings-visualization/05-04-SUMMARY.md`
</output>
