---
phase: 03-filtering-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/repositories/duckdb_repo.py
  - app/services/filter_builder.py
  - app/models/sample.py
  - app/routers/samples.py
  - app/main.py
  - frontend/src/stores/filter-store.ts
  - frontend/src/types/sample.ts
  - frontend/src/types/filter.ts
  - frontend/src/hooks/use-samples.ts
  - frontend/src/hooks/use-filter-facets.ts
  - frontend/src/components/filters/filter-sidebar.tsx
  - frontend/src/components/filters/filter-select.tsx
  - frontend/src/components/grid/image-grid.tsx
  - frontend/src/app/datasets/[datasetId]/page.tsx
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "User can filter the grid by category via sidebar dropdown and see only matching samples"
    - "User can filter the grid by split via sidebar dropdown and see only matching samples"
    - "User can clear all filters and see the full unfiltered grid"
    - "Filter options (categories, splits) are populated dynamically from the dataset"
  artifacts:
    - path: "app/services/filter_builder.py"
      provides: "SampleFilterBuilder with parameterized SQL query construction"
      contains: "class SampleFilterBuilder"
    - path: "frontend/src/stores/filter-store.ts"
      provides: "Zustand filter state with atomic selectors"
      exports: ["useFilterStore"]
    - path: "frontend/src/components/filters/filter-sidebar.tsx"
      provides: "Sidebar with category and split filter dropdowns"
      contains: "FilterSidebar"
    - path: "frontend/src/hooks/use-filter-facets.ts"
      provides: "Hook fetching distinct filter values"
      exports: ["useFilterFacets"]
  key_links:
    - from: "frontend/src/hooks/use-samples.ts"
      to: "frontend/src/stores/filter-store.ts"
      via: "Filter state included in TanStack Query queryKey"
      pattern: "queryKey.*samples.*filters"
    - from: "app/routers/samples.py"
      to: "app/services/filter_builder.py"
      via: "SampleFilterBuilder used in list_samples endpoint"
      pattern: "SampleFilterBuilder"
    - from: "frontend/src/components/filters/filter-sidebar.tsx"
      to: "frontend/src/stores/filter-store.ts"
      via: "Sidebar dispatches filter actions to Zustand store"
      pattern: "useFilterStore"
---

<objective>
Build the backend filter infrastructure (dynamic SQL query builder, extended samples endpoint, filter facets endpoint, tags column migration) and the frontend filter sidebar with Zustand filter state management integrated into TanStack Query for automatic refetch-on-filter-change.

Purpose: Delivers FILT-01 (sidebar metadata filters for category and split). Establishes the filter architecture that Plan 03-02 extends with search, sort, saved views, and tagging.
Output: Working sidebar that filters the image grid by category and split, with dynamically populated dropdown options.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-filtering-search/03-RESEARCH.md
@.planning/phases/01-data-foundation/01-04-SUMMARY.md
@.planning/phases/02-visual-grid/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend filter infrastructure -- schema migration, filter builder, extended samples endpoint, facets endpoint</name>
  <files>
    app/repositories/duckdb_repo.py
    app/services/filter_builder.py
    app/models/sample.py
    app/routers/samples.py
  </files>
  <action>
    **1. Schema migration (duckdb_repo.py):**
    Add to `initialize_schema()` after the existing CREATE TABLE statements:
    - `ALTER TABLE samples ADD COLUMN IF NOT EXISTS tags VARCHAR[] DEFAULT [];`
    - CREATE TABLE IF NOT EXISTS saved_views (id VARCHAR NOT NULL, dataset_id VARCHAR NOT NULL, name VARCHAR NOT NULL, filters JSON NOT NULL, created_at TIMESTAMP DEFAULT current_timestamp, updated_at TIMESTAMP DEFAULT current_timestamp)

    **2. SampleFilterBuilder service (NEW file: app/services/filter_builder.py):**
    Create the SampleFilterBuilder class following the exact pattern from 03-RESEARCH.md Pattern 1:
    - `FilterResult` dataclass with where_clause, params, join_clause, order_clause
    - `SORTABLE_COLUMNS = {"id", "file_name", "width", "height", "split"}` -- allowlist for SQL injection prevention
    - Builder methods: `add_dataset()`, `add_split()`, `add_category()`, `add_search()`, `add_tags()`, `build_order()`, `build()`
    - All user input via parameterized queries (`?` placeholders). Column names validated against allowlist.
    - `add_category()` adds a JOIN to the annotations table
    - `add_search()` uses `s.file_name ILIKE ?` with `%search%` wrapping
    - `add_tags()` uses `list_contains(s.tags, ?)` for each tag (AND logic)
    - `build()` returns FilterResult with joined conditions, params, join, and order clause

    **3. Extend SampleResponse model (app/models/sample.py):**
    - Add `tags: list[str] = []` field to `SampleResponse`
    - Add `SampleFilterParams` Pydantic model for the extended query parameters:
      - dataset_id: str, category: str | None = None, split: str | None = None, search: str | None = None, tags: str | None = None (comma-separated), sort_by: str = "id", sort_dir: Literal["asc", "desc"] = "asc", offset: int = Field(0, ge=0), limit: int = Field(50, ge=1, le=200)

    **4. Refactor list_samples endpoint (app/routers/samples.py):**
    Replace the inline SQL building with SampleFilterBuilder:
    - Import SampleFilterBuilder from app.services.filter_builder
    - Keep the same endpoint signature but accept the new query params (search, tags, sort_by, sort_dir) in addition to existing (dataset_id, category, split, offset, limit). Use individual Query() params (NOT Pydantic Query model -- FastAPI Query Parameter Models require v0.115+ and the existing codebase uses individual params).
    - Parse tags from comma-separated string to list
    - Build query using SampleFilterBuilder chain: add_dataset -> add_split -> add_category -> add_search -> add_tags -> build(sort_by, sort_dir)
    - Use FilterResult for count SQL and data SQL
    - Include `s.tags` in the SELECT columns
    - Include `tags=row[7] or []` in SampleResponse construction
    - Handle DISTINCT when join_clause is present (category filter)

    **5. Add filter-facets endpoint (app/routers/samples.py):**
    Add `GET /samples/filter-facets` endpoint (MUST be defined BEFORE the `/{sample_id}/annotations` path route to avoid route conflicts):
    - Accepts `dataset_id: str = Query(...)`
    - Returns dict with `categories`, `splits`, `tags` lists
    - Categories: `SELECT DISTINCT category_name FROM annotations WHERE dataset_id = ? ORDER BY category_name`
    - Splits: `SELECT DISTINCT split FROM samples WHERE dataset_id = ? AND split IS NOT NULL ORDER BY split`
    - Tags: `SELECT DISTINCT UNNEST(tags) AS tag FROM samples WHERE dataset_id = ? AND tags IS NOT NULL ORDER BY tag`
    - Use cursor-per-request pattern (cursor in try/finally)
  </action>
  <verify>
    Run the backend tests to ensure existing tests still pass:
    ```bash
    cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && python -m pytest tests/ -x -q
    ```
    Verify the filter_builder module imports cleanly:
    ```bash
    python -c "from app.services.filter_builder import SampleFilterBuilder, FilterResult; print('OK')"
    ```
    Verify the schema migration runs:
    ```bash
    python -c "
    from app.repositories.duckdb_repo import DuckDBRepo
    db = DuckDBRepo(':memory:')
    db.initialize_schema()
    cols = [r[0] for r in db.connection.execute('PRAGMA table_info(samples)').fetchall()]
    assert 'tags' in cols, f'tags column missing: {cols}'
    tables = [r[0] for r in db.connection.execute(\"SELECT table_name FROM information_schema.tables WHERE table_name = 'saved_views'\").fetchall()]
    assert 'saved_views' in tables, f'saved_views table missing: {tables}'
    db.close()
    print('Schema OK')
    "
    ```
  </verify>
  <done>
    - SampleFilterBuilder constructs parameterized SQL with all filter types (dataset, split, category, search, tags, sort)
    - GET /samples accepts search, tags, sort_by, sort_dir params and returns filtered + sorted results with tags field
    - GET /samples/filter-facets returns distinct categories, splits, and tags for a dataset
    - samples table has tags VARCHAR[] column, saved_views table exists
    - All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend filter sidebar -- Zustand store, filter components, TanStack Query integration, grid layout</name>
  <files>
    frontend/src/stores/filter-store.ts
    frontend/src/types/sample.ts
    frontend/src/types/filter.ts
    frontend/src/hooks/use-samples.ts
    frontend/src/hooks/use-filter-facets.ts
    frontend/src/components/filters/filter-sidebar.tsx
    frontend/src/components/filters/filter-select.tsx
    frontend/src/components/grid/image-grid.tsx
    frontend/src/app/datasets/[datasetId]/page.tsx
    frontend/src/lib/api.ts
  </files>
  <action>
    **1. Filter types (NEW file: frontend/src/types/filter.ts):**
    ```typescript
    export interface FilterFacets {
      categories: string[];
      splits: string[];
      tags: string[];
    }
    ```

    **2. Update Sample type (frontend/src/types/sample.ts):**
    Add `tags: string[]` to the Sample interface (matches updated backend SampleResponse).

    **3. Zustand filter store (NEW file: frontend/src/stores/filter-store.ts):**
    Follow 03-RESEARCH.md Pattern 2 exactly:
    - FilterState interface with: search, category, split, tags, sortBy, sortDir, plus setters + clearFilters + applyView
    - DEFAULT_FILTERS const with sensible defaults (search: "", category: null, split: null, tags: [], sortBy: "id", sortDir: "asc")
    - `create<FilterState>` with spread DEFAULT_FILTERS and action implementations
    - Export atomic selectors: useSearch, useCategory, useSplit, useTags, useSortBy, useSortDir, useFilterActions
    - Export useActiveFilterCount selector that counts non-default filters (for badge display)

    **4. Update useSamples hook (frontend/src/hooks/use-samples.ts):**
    Follow 03-RESEARCH.md Pattern 2 integration:
    - Import useFilterStore
    - Read filter state from store: search, category, split, tags, sortBy, sortDir
    - Build `filters` object and include it in queryKey: `["samples", datasetId, filters]`
    - Sort tags array in queryKey for structural stability: `tags: [...tags].sort()`
    - Build URLSearchParams from filter state in queryFn
    - Only add non-null/non-empty params to URLSearchParams

    **5. Filter facets hook (NEW file: frontend/src/hooks/use-filter-facets.ts):**
    - Use `useQuery` (not infinite) with queryKey: `["filter-facets", datasetId]`
    - staleTime: 5 * 60 * 1000 (5 minutes) -- facets are per-dataset, not per-filter
    - Fetch from `/samples/filter-facets?dataset_id=${datasetId}`
    - Return type: FilterFacets

    **6. FilterSelect component (NEW file: frontend/src/components/filters/filter-select.tsx):**
    A reusable single-select dropdown for category/split filters:
    - Props: `label: string`, `options: string[]`, `value: string | null`, `onChange: (value: string | null) => void`
    - Render a `<select>` with a "All" default option (value="") that maps to null
    - Options populated from the `options` prop
    - Tailwind styling matching the existing dark mode classes (dark:bg-zinc-800, dark:border-zinc-600, etc.)
    - When value is "", call onChange(null) to clear the filter

    **7. FilterSidebar component (NEW file: frontend/src/components/filters/filter-sidebar.tsx):**
    Follow 03-RESEARCH.md sidebar structure:
    - Import useFilterFacets, useFilterStore
    - Props: `datasetId: string`
    - Render `<aside>` with fixed width (w-64) and border-r
    - Header: "Filters" title + "Clear all" button (calls clearFilters from store)
    - FilterSelect for Category (storeKey: category, options from facets.categories)
    - FilterSelect for Split (storeKey: split, options from facets.splits)
    - Connect each FilterSelect's onChange to the corresponding store setter (setCategory, setSplit)
    - Read current values from store for controlled components

    **8. Update page layout (frontend/src/app/datasets/[datasetId]/page.tsx):**
    - Import FilterSidebar
    - Wrap the ImageGrid in a flex row container with the FilterSidebar on the left:
      ```
      <div className="flex flex-1 overflow-hidden">
        <FilterSidebar datasetId={datasetId} />
        <div className="flex-1 overflow-hidden">
          <ImageGrid datasetId={datasetId} />
        </div>
      </div>
      ```
    - The sidebar sits left of the grid. The grid fills remaining space.
    - Note: useSamples is called inside ImageGrid, which now reads from filter-store. No prop drilling needed -- the query key change triggers automatic refetch.

    **9. Update ImageGrid height calculation (frontend/src/components/grid/image-grid.tsx):**
    - The grid's scroll container height needs adjustment since it's now inside a flex layout:
      Change `style={{ height: "calc(100vh - 120px)" }}` to `className="flex-1 overflow-auto"` (let flexbox handle height).
    - The "Showing X of Y samples" bar should reflect filtered counts.

    **10. Add apiPost helper (frontend/src/lib/api.ts):**
    Add `apiPost`, `apiPatch`, and `apiDelete` functions following the pattern from 03-RESEARCH.md. These will be used by Plan 03-02 for mutations but should be created now since we're touching api.ts.
  </action>
  <verify>
    Build the frontend to check for TypeScript errors:
    ```bash
    cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor/frontend && npm run build 2>&1 | tail -20
    ```
    If the build fails, check the specific errors and fix them. Common issues:
    - Missing imports (filter-store, filter types)
    - Type mismatches (Sample now has tags field)
  </verify>
  <done>
    - Zustand filter-store.ts manages filter state with atomic selectors
    - useSamples includes filter state in queryKey -- changing a filter triggers automatic refetch
    - useFilterFacets fetches distinct categories/splits/tags with 5-min staleTime
    - FilterSidebar renders category and split dropdowns populated from facets
    - "Clear all" button resets all filters
    - Grid layout has sidebar on left, image grid on right
    - Frontend builds without TypeScript errors
    - Sample type includes tags field
    - apiPost, apiPatch, apiDelete helpers exist for Plan 03-02
  </done>
</task>

</tasks>

<verification>
1. Start backend: `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && uvicorn app.main:app --reload`
2. Start frontend: `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor/frontend && npm run dev`
3. Navigate to a dataset page -- sidebar should appear on the left with Category and Split dropdowns
4. Select a category -- grid should filter to only samples with that category's annotations
5. Select a split -- grid should further filter by split
6. Click "Clear all" -- grid should show all samples again
7. Verify filter-facets endpoint returns correct data: `curl "http://localhost:8000/samples/filter-facets?dataset_id=YOUR_DATASET_ID"`
8. Verify extended samples endpoint with filters: `curl "http://localhost:8000/samples?dataset_id=YOUR_DATASET_ID&category=person&sort_by=file_name&sort_dir=desc"`
</verification>

<success_criteria>
- Sidebar with Category and Split filter dropdowns renders next to the image grid
- Selecting a filter updates the grid in real-time (via TanStack Query key change)
- Filter options are dynamically populated from the dataset (not hardcoded)
- "Clear all" resets filters and shows the full dataset
- Backend filter-facets endpoint returns distinct values
- Backend samples endpoint accepts and applies search, tags, sort_by, sort_dir params
- DuckDB schema includes tags column on samples and saved_views table
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-filtering-search/03-01-SUMMARY.md`
</output>
