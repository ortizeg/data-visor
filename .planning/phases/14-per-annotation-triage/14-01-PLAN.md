---
phase: 14-per-annotation-triage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/repositories/duckdb_repo.py
  - app/models/annotation_triage.py
  - app/services/annotation_matching.py
  - app/routers/annotation_triage.py
  - app/main.py
autonomous: true

must_haves:
  truths:
    - "GET /samples/{sample_id}/annotation-triage returns per-annotation TP/FP/FN classifications computed via IoU matching"
    - "PATCH /samples/set-annotation-triage persists a manual triage override for a single annotation"
    - "DELETE /samples/{sample_id}/annotation-triage/{annotation_id} removes a manual override"
    - "Manual overrides take precedence over auto-computed IoU labels in the merged response"
  artifacts:
    - path: "app/repositories/duckdb_repo.py"
      provides: "annotation_triage table creation in initialize_schema"
      contains: "CREATE TABLE IF NOT EXISTS annotation_triage"
    - path: "app/models/annotation_triage.py"
      provides: "Pydantic models for triage request/response"
      exports: ["AnnotationTriageResult", "SetAnnotationTriageRequest", "AnnotationTriageResponse"]
    - path: "app/services/annotation_matching.py"
      provides: "Single-sample IoU matching with annotation IDs"
      exports: ["match_sample_annotations"]
    - path: "app/routers/annotation_triage.py"
      provides: "GET/PATCH/DELETE annotation triage endpoints"
      exports: ["router"]
    - path: "app/main.py"
      provides: "Router registration for annotation_triage"
      contains: "annotation_triage"
  key_links:
    - from: "app/routers/annotation_triage.py"
      to: "app/services/annotation_matching.py"
      via: "match_sample_annotations call in GET endpoint"
      pattern: "match_sample_annotations"
    - from: "app/services/annotation_matching.py"
      to: "app/services/evaluation.py"
      via: "_compute_iou_matrix import for IoU computation"
      pattern: "from app.services.evaluation import _compute_iou_matrix"
    - from: "app/routers/annotation_triage.py"
      to: "annotation_triage table"
      via: "INSERT/DELETE for manual overrides"
      pattern: "annotation_triage"
---

<objective>
Build the backend infrastructure for per-annotation triage: DuckDB schema, IoU matching service, and API endpoints.

Purpose: Enables computing TP/FP/FN classifications per bounding box and persisting manual overrides -- the data layer that the frontend will consume.
Output: Three new files (models, service, router) plus schema migration and router registration.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-per-annotation-triage/14-RESEARCH.md

# Key source files for implementation patterns
@app/services/evaluation.py
@app/services/error_analysis.py
@app/routers/triage.py
@app/models/triage.py
@app/dependencies.py
@app/repositories/duckdb_repo.py
@app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration + Pydantic models + IoU matching service</name>
  <files>
    app/repositories/duckdb_repo.py
    app/models/annotation_triage.py
    app/services/annotation_matching.py
  </files>
  <action>
    1. **Schema migration** in `app/repositories/duckdb_repo.py`:
       Add to `initialize_schema()` method (after the embeddings table creation):
       ```sql
       CREATE TABLE IF NOT EXISTS annotation_triage (
           annotation_id   VARCHAR NOT NULL,
           dataset_id      VARCHAR NOT NULL,
           sample_id       VARCHAR NOT NULL,
           label           VARCHAR NOT NULL,
           is_override     BOOLEAN DEFAULT true,
           created_at      TIMESTAMP DEFAULT current_timestamp
       )
       ```

    2. **Pydantic models** in `app/models/annotation_triage.py`:
       - `AnnotationTriageResult`: annotation_id (str), auto_label (str: "tp"|"fp"|"fn"|"label_error"), label (str: final label after override merge), matched_id (str|None), iou (float|None), is_override (bool)
       - `AnnotationTriageResponse`: items (list[AnnotationTriageResult]) -- the response for the GET endpoint
       - `SetAnnotationTriageRequest`: annotation_id (str), dataset_id (str), sample_id (str), label (str) -- the request for the PATCH endpoint
       - `VALID_ANNOTATION_TRIAGE_LABELS`: set = {"tp", "fp", "fn", "mistake"} -- validation constant

    3. **IoU matching service** in `app/services/annotation_matching.py`:
       Create `match_sample_annotations(cursor, dataset_id, sample_id, source, iou_threshold=0.5, conf_threshold=0.25)` that returns `dict[str, dict]` mapping annotation_id to {"label": str, "matched_id": str|None, "iou": float|None}.

       Implementation (following the research code example closely):
       - Query GT annotations WITH IDs: `SELECT id, category_name, bbox_x, bbox_y, bbox_w, bbox_h, confidence FROM annotations WHERE dataset_id=? AND sample_id=? AND source='ground_truth'`
       - Query prediction annotations WITH IDs: same query but `source=?` (the prediction source parameter)
       - Filter predictions by conf_threshold, sort by confidence descending
       - Build GT xyxy numpy array from bbox coords
       - For each prediction: compute IoU against all GT via `_compute_iou_matrix` (import from `app.services.evaluation`), find best match, classify as tp/label_error/fp using greedy matching with matched_gt set tracking
       - Mark unmatched GT as fn, matched GT as tp
       - Return results dict keyed by annotation_id

       IMPORTANT: Unlike `_load_detections()` which drops annotation IDs, this function queries WITH `id` column so results can be mapped back to specific annotations. This is the key difference from the existing error_analysis.py approach.
  </action>
  <verify>
    Run `python -c "from app.services.annotation_matching import match_sample_annotations; print('OK')"` to confirm import works.
    Run `python -c "from app.models.annotation_triage import AnnotationTriageResponse, SetAnnotationTriageRequest, VALID_ANNOTATION_TRIAGE_LABELS; print('OK')"` to confirm models import.
    Start the server briefly and verify the annotation_triage table is created: `python -c "from app.repositories.duckdb_repo import DuckDBRepo; db = DuckDBRepo('data/datavisor.duckdb'); print(db.connection.execute('SELECT table_name FROM information_schema.tables WHERE table_name = %s', ['annotation_triage']).fetchall())"` (should return the table).
  </verify>
  <done>
    annotation_triage table exists in DuckDB schema. Pydantic models validate correctly. match_sample_annotations function imports and accepts the expected parameters. _compute_iou_matrix is reused from evaluation.py (not hand-rolled).
  </done>
</task>

<task type="auto">
  <name>Task 2: Annotation triage router + main.py registration</name>
  <files>
    app/routers/annotation_triage.py
    app/main.py
  </files>
  <action>
    1. **Router** in `app/routers/annotation_triage.py`:
       Create a FastAPI APIRouter with prefix="/samples", tags=["annotation-triage"]. Follow the pattern from `triage.py` (uses `get_db` DI, cursor management).

       Three endpoints:

       **GET `/{sample_id}/annotation-triage`**:
       - Query params: dataset_id (str, required), source (str, default="prediction"), iou_threshold (float, default=0.5, ge=0.1, le=1.0), conf_threshold (float, default=0.25, ge=0.0, le=1.0)
       - Call `match_sample_annotations(cursor, dataset_id, sample_id, source, iou_threshold, conf_threshold)` to get auto-computed labels
       - Query `annotation_triage` table for manual overrides: `SELECT annotation_id, label FROM annotation_triage WHERE dataset_id=? AND sample_id=?`
       - Merge: build AnnotationTriageResult list. For each annotation_id in auto results, check if override exists. If yes, set label=override.label and is_override=True. If no, set label=auto_label and is_override=False.
       - Return `AnnotationTriageResponse(items=[...])` with response_model=AnnotationTriageResponse

       **PATCH `/set-annotation-triage`**:
       - Body: SetAnnotationTriageRequest
       - Validate label is in VALID_ANNOTATION_TRIAGE_LABELS (raise 400 if not)
       - DELETE existing override: `DELETE FROM annotation_triage WHERE annotation_id=? AND dataset_id=?`
       - INSERT new override: `INSERT INTO annotation_triage (annotation_id, dataset_id, sample_id, label) VALUES (?, ?, ?, ?)`
       - ALSO set a sample-level tag `triage:annotated` on the sample (so highlight mode works): use the same atomic pattern from triage.py -- `UPDATE samples SET tags = list_distinct(list_append(list_filter(COALESCE(tags, []), x -> NOT starts_with(x, 'triage:ann')), 'triage:annotated')) WHERE dataset_id=? AND id=?`
       - Return {"annotation_id": ..., "label": ...}

       **DELETE `/{sample_id}/annotation-triage/{annotation_id}`**:
       - Query param: dataset_id (str, required)
       - DELETE from annotation_triage: `DELETE FROM annotation_triage WHERE annotation_id=? AND dataset_id=?`
       - Check if sample has any remaining annotation triage overrides. If none, remove the `triage:annotated` tag from sample tags.
       - Return {"annotation_id": ..., "cleared": true}

    2. **Register router** in `app/main.py`:
       - Import: `from app.routers import annotation_triage`
       - Add: `app.include_router(annotation_triage.router)` after the existing triage router registrations
  </action>
  <verify>
    Start the backend server: `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && python -m uvicorn app.main:app --host 0.0.0.0 --port 8000` (should start without import errors).
    Check OpenAPI docs at http://localhost:8000/docs -- the three new annotation-triage endpoints should appear.
    Test GET endpoint: `curl "http://localhost:8000/samples/SAMPLE_ID/annotation-triage?dataset_id=DATASET_ID"` should return JSON (even if empty items array for a sample without predictions).
  </verify>
  <done>
    Three endpoints registered and accessible. GET returns IoU-computed classifications merged with overrides. PATCH persists override and sets sample-level triage:annotated tag. DELETE removes override and cleans up sample tag when no overrides remain. Server starts without errors.
  </done>
</task>

</tasks>

<verification>
1. Backend server starts without import errors
2. `annotation_triage` table exists in DuckDB
3. GET endpoint returns per-annotation classifications for a sample with GT + predictions
4. PATCH endpoint persists an override and it appears in subsequent GET
5. DELETE endpoint removes the override
6. OpenAPI docs show all three endpoints with correct schemas
</verification>

<success_criteria>
- IoU matching service reuses `_compute_iou_matrix` from evaluation.py (no duplicate IoU code)
- Auto-computed labels are ephemeral (computed on GET, not stored)
- Manual overrides persist in `annotation_triage` table and take precedence over auto labels
- Sample-level `triage:annotated` tag bridges per-annotation triage to existing highlight mode
- All endpoints follow established patterns (get_db DI, cursor management, Pydantic models)
</success_criteria>

<output>
After completion, create `.planning/phases/14-per-annotation-triage/14-01-SUMMARY.md`
</output>
