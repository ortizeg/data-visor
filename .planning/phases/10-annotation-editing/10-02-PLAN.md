---
phase: 10-annotation-editing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/src/lib/coord-utils.ts
  - frontend/src/components/detail/editable-rect.tsx
  - frontend/src/components/detail/draw-layer.tsx
  - frontend/src/components/detail/class-picker.tsx
autonomous: true

must_haves:
  truths:
    - "EditableRect renders a Konva Rect that is draggable and has a Transformer when selected"
    - "EditableRect converts Transformer scaleX/scaleY back to width/height on transformEnd and resets scale to 1"
    - "DrawLayer allows drawing a new rectangle via mousedown-mousemove-mouseup on the Stage"
    - "DrawLayer normalizes negative width/height from right-to-left or bottom-to-top drawing"
    - "ClassPicker shows a dropdown of available category names and calls onSelect with the chosen category"
    - "Coordinate utils correctly convert between original pixel space and canvas display space"
  artifacts:
    - path: "frontend/src/lib/coord-utils.ts"
      provides: "getScaleFactors, toCanvasCoords, toOriginalCoords, normalizeRect"
      exports: ["getScaleFactors", "toCanvasCoords", "toOriginalCoords", "normalizeRect"]
    - path: "frontend/src/components/detail/editable-rect.tsx"
      provides: "EditableRect component with Konva Transformer"
      exports: ["EditableRect"]
    - path: "frontend/src/components/detail/draw-layer.tsx"
      provides: "DrawLayer component for drawing new bounding boxes"
      exports: ["DrawLayer"]
    - path: "frontend/src/components/detail/class-picker.tsx"
      provides: "ClassPicker dropdown component"
      exports: ["ClassPicker"]
  key_links:
    - from: "frontend/src/components/detail/editable-rect.tsx"
      to: "Konva Transformer"
      via: "useRef + useEffect attachment"
      pattern: "trRef\\.current\\.nodes\\(\\[shapeRef\\.current\\]\\)"
    - from: "frontend/src/components/detail/editable-rect.tsx"
      to: "parent onChange callback"
      via: "onDragEnd and onTransformEnd"
      pattern: "onChange\\(\\{.*x:.*y:.*width:.*height:"
    - from: "frontend/src/components/detail/draw-layer.tsx"
      to: "parent onDrawComplete callback"
      via: "mouseup handler with normalizeRect"
      pattern: "normalizeRect"
---

<objective>
Build the Konva canvas building blocks: coordinate conversion utilities, EditableRect (drag + resize via Transformer), DrawLayer (new box drawing via Stage mouse events), and ClassPicker (category assignment dropdown). Also install react-konva, konva, use-image, and uuid dependencies.

Purpose: These are the pure UI primitives that Plan 03 will compose into the AnnotationEditor and wire into the sample modal. Building them independently keeps each plan focused and testable.
Output: Four reusable components/utilities that compile cleanly and follow Konva best practices from the research.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-annotation-editing/10-RESEARCH.md

Key existing files:
@frontend/src/components/grid/annotation-overlay.tsx (SVG overlay -- reference for color usage)
@frontend/src/lib/color-hash.ts (getClassColor, getSourceColor)
@frontend/src/types/annotation.ts (Annotation type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Konva dependencies and create coordinate utilities</name>
  <files>
    frontend/package.json
    frontend/src/lib/coord-utils.ts
  </files>
  <action>
    1. Install dependencies:
       ```bash
       cd frontend && npm install react-konva konva use-image uuid && npm install -D @types/uuid
       ```
       Note: `use-image` ships its own types. react-konva 19.x is needed for React 19 compatibility.

    2. Create `frontend/src/lib/coord-utils.ts` with these exports:

       a) `ScaleFactors` interface: `{ scaleX: number; scaleY: number }`

       b) `getScaleFactors(originalWidth, originalHeight, displayWidth, displayHeight)` -> ScaleFactors
          - scaleX = displayWidth / originalWidth
          - scaleY = displayHeight / originalHeight

       c) `toCanvasCoords(bbox: { bbox_x, bbox_y, bbox_w, bbox_h }, scale: ScaleFactors)` -> `{ x, y, width, height }`
          - Converts annotation coords (original pixel space) to Konva display coords
          - x = bbox.bbox_x * scale.scaleX, y = bbox.bbox_y * scale.scaleY
          - width = bbox.bbox_w * scale.scaleX, height = bbox.bbox_h * scale.scaleY

       d) `toOriginalCoords(canvasRect: { x, y, width, height }, scale: ScaleFactors)` -> `{ bbox_x, bbox_y, bbox_w, bbox_h }`
          - Converts Konva display coords back to original pixel space for DuckDB storage
          - bbox_x = canvasRect.x / scale.scaleX, etc.

       e) `normalizeRect(rect: { x, y, width, height })` -> `{ x, y, width, height }`
          - Handles negative width/height from drawing right-to-left or bottom-to-top
          - If width < 0: x = x + width, width = abs(width)
          - If height < 0: y = y + height, height = abs(height)

       All functions are pure (no side effects). Export the ScaleFactors type as well.
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes. coord-utils.ts has no import errors.
  </verify>
  <done>
    react-konva, konva, use-image, uuid installed. coord-utils.ts exports 4 functions and 1 type for coordinate conversion between SVG/original pixel space and Konva canvas display space.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EditableRect, DrawLayer, and ClassPicker components</name>
  <files>
    frontend/src/components/detail/editable-rect.tsx
    frontend/src/components/detail/draw-layer.tsx
    frontend/src/components/detail/class-picker.tsx
  </files>
  <action>
    1. Create `frontend/src/components/detail/editable-rect.tsx`:
       - "use client" directive at top
       - Import from react-konva: Rect, Transformer
       - Import from react: useRef, useEffect
       - Import Konva namespace type from "konva" (for Konva.Rect, Konva.Transformer refs)

       Props interface `EditableRectProps`:
       - `shapeProps`: `{ x: number; y: number; width: number; height: number }` (canvas-space coords)
       - `stroke`: string (color for this annotation's class)
       - `isSelected`: boolean
       - `onSelect`: `() => void`
       - `onChange`: `(newAttrs: { x: number; y: number; width: number; height: number }) => void`

       Implementation:
       - shapeRef = useRef<Konva.Rect>(null)
       - trRef = useRef<Konva.Transformer>(null)
       - useEffect: when isSelected && both refs exist, attach Transformer to shape via `trRef.current.nodes([shapeRef.current])` then `trRef.current.getLayer()?.batchDraw()`
       - Render `<Rect>` with:
         - ref={shapeRef}, {...shapeProps}, fill="transparent"
         - stroke={props.stroke}, strokeWidth={2}
         - draggable={true}
         - onClick/onTap -> onSelect (with `e.cancelBubble = true` to prevent Stage deselection)
         - onDragEnd: call onChange with `{ ...shapeProps, x: e.target.x(), y: e.target.y() }`
         - onTransformEnd: read scaleX/scaleY from node, compute new width/height, reset scale to 1, call onChange. Use `Math.max(5, ...)` for minimum size.
       - Conditionally render `<Transformer>` when isSelected:
         - ref={trRef}, flipEnabled={false}, rotateEnabled={false}
         - boundBoxFunc: reject boxes smaller than 5px in either dimension
         - anchorSize={8}, borderStroke={props.stroke}

    2. Create `frontend/src/components/detail/draw-layer.tsx`:
       - "use client" directive
       - Import from react-konva: Rect
       - Import from react: useState

       Props interface `DrawLayerProps`:
       - `active`: boolean (is draw mode active)
       - `stageRef`: React.RefObject<Konva.Stage | null> (to get pointer position)
       - `onDrawComplete`: `(rect: { x: number; y: number; width: number; height: number }) => void`

       Implementation:
       - Internal state: `isDrawing` (boolean), `newRect` (rect or null)
       - Expose a `handleMouseDown(e: Konva.KonvaEventObject<MouseEvent>)` function:
         - Only act if `active` and target is the Stage itself (click on empty area)
         - Get pointer position from stage, set newRect start, set isDrawing=true
       - Expose `handleMouseMove(e: Konva.KonvaEventObject<MouseEvent>)`:
         - Only act if isDrawing && newRect
         - Update newRect width/height based on current pointer pos minus start
       - Expose `handleMouseUp()`:
         - If isDrawing && newRect && both abs(width) > 10 and abs(height) > 10:
           - Import and use `normalizeRect` from coord-utils
           - Call `onDrawComplete(normalizeRect(newRect))`
         - Reset isDrawing and newRect

       IMPORTANT: This component does NOT render a Stage. It provides:
       - The three mouse handler functions (exported for the parent Stage to call)
       - A preview `<Rect>` rendered only when isDrawing && newRect exists
       - The Rect should have: stroke="#00ff00", strokeWidth={2}, dash={[6,3]}, fill="rgba(0,255,0,0.1)", listening={false}

       Export pattern: Use a custom hook `useDrawLayer(props)` that returns `{ handlers: { onMouseDown, onMouseMove, onMouseUp }, previewRect: ReactNode | null }`. This keeps the draw logic reusable without requiring a separate Layer.

    3. Create `frontend/src/components/detail/class-picker.tsx`:
       - "use client" directive
       - A positioned dropdown for assigning a class to a newly drawn bounding box

       Props interface `ClassPickerProps`:
       - `categories`: string[] (available category names from the dataset)
       - `position`: { x: number; y: number } (screen position to render near the drawn box)
       - `onSelect`: `(categoryName: string) => void`
       - `onCancel`: `() => void`

       Implementation:
       - Render a small absolute-positioned div at `position` (use style={{ left, top }})
       - Show a text input for typing/filtering + a scrollable list of categories
       - Each category row shows a colored dot (via getClassColor) and the category name
       - Clicking a category calls onSelect(categoryName)
       - Pressing Escape or clicking outside calls onCancel
       - Allow typing a NEW category name not in the list and pressing Enter to use it
       - Use useRef for the container div + useEffect to focus the input on mount
       - Use useEffect with mousedown listener on document to detect outside clicks

       Style with Tailwind: white bg, rounded shadow-lg border, max-h-48 overflow-auto for the list, p-2. Dark mode support with dark:bg-zinc-800 etc.
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes with no errors for all three new components.
  </verify>
  <done>
    EditableRect renders a draggable Konva Rect with Transformer (8 resize handles, no rotation, 5px min). DrawLayer provides mouse handlers and preview rect for drawing new boxes. ClassPicker shows a filterable category dropdown with support for new categories. All components compile cleanly.
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npx tsc --noEmit` passes (all new files compile)
- `npm ls react-konva konva use-image uuid` shows all four packages installed
- coord-utils.ts exports getScaleFactors, toCanvasCoords, toOriginalCoords, normalizeRect
- EditableRect uses Konva Transformer with scale-to-width conversion on transformEnd
- DrawLayer normalizes negative rectangles before calling onDrawComplete
- ClassPicker supports both selecting existing and typing new category names
</verification>

<success_criteria>
- react-konva 19.x, konva 10.x, use-image, uuid installed in frontend
- Coordinate conversion works bidirectionally (original pixel <-> canvas display)
- EditableRect handles drag (onDragEnd) and resize (onTransformEnd with scale reset)
- DrawLayer provides Stage-level mouse handlers and a preview rectangle
- ClassPicker renders a positioned dropdown with category filtering
- All new code compiles with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-annotation-editing/10-02-SUMMARY.md`
</output>
