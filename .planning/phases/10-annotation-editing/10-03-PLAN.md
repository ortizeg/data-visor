---
phase: 10-annotation-editing
plan: 03
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - frontend/src/stores/ui-store.ts
  - frontend/src/components/detail/annotation-editor.tsx
  - frontend/src/components/detail/sample-modal.tsx
  - frontend/src/components/detail/annotation-list.tsx
autonomous: true

must_haves:
  truths:
    - "User can toggle edit mode in the sample detail modal via an Edit/Done button"
    - "In edit mode, the SVG overlay is replaced by a Konva canvas with editable ground_truth boxes"
    - "Prediction annotations appear as dashed, non-interactive overlays in edit mode"
    - "User can drag a ground_truth bounding box to reposition it and the change persists to the backend"
    - "User can resize a ground_truth bounding box via handles and the change persists to the backend"
    - "User can click a delete button on an annotation row and it is removed from DuckDB"
    - "User can enter draw mode, draw a new rectangle, pick a class, and the new annotation persists"
    - "Closing edit mode switches back to SVG overlay view"
  artifacts:
    - path: "frontend/src/stores/ui-store.ts"
      provides: "isEditMode and selectedAnnotationId state + actions"
      contains: "isEditMode"
    - path: "frontend/src/components/detail/annotation-editor.tsx"
      provides: "AnnotationEditor Konva composition component"
      exports: ["AnnotationEditor"]
    - path: "frontend/src/components/detail/sample-modal.tsx"
      provides: "Edit mode toggle + conditional AnnotationEditor vs SVG rendering"
      contains: "isEditMode"
    - path: "frontend/src/components/detail/annotation-list.tsx"
      provides: "Delete button on ground_truth annotation rows"
      contains: "onDelete"
  key_links:
    - from: "frontend/src/components/detail/annotation-editor.tsx"
      to: "frontend/src/components/detail/editable-rect.tsx"
      via: "renders EditableRect for each ground_truth annotation"
      pattern: "<EditableRect"
    - from: "frontend/src/components/detail/annotation-editor.tsx"
      to: "frontend/src/lib/coord-utils.ts"
      via: "toCanvasCoords and toOriginalCoords for coordinate conversion"
      pattern: "toCanvasCoords|toOriginalCoords"
    - from: "frontend/src/components/detail/sample-modal.tsx"
      to: "frontend/src/hooks/use-annotations.ts"
      via: "useUpdateAnnotation, useCreateAnnotation, useDeleteAnnotation"
      pattern: "use(Update|Create|Delete)Annotation"
    - from: "frontend/src/components/detail/sample-modal.tsx"
      to: "frontend/src/components/detail/annotation-editor.tsx"
      via: "conditional render based on isEditMode"
      pattern: "isEditMode.*AnnotationEditor"
    - from: "frontend/src/components/detail/annotation-list.tsx"
      to: "delete mutation"
      via: "onDelete callback prop"
      pattern: "onDelete\\(ann\\.id\\)"
---

<objective>
Compose the AnnotationEditor from the Konva building blocks (Plan 02), wire it into the sample detail modal with edit mode toggle, connect mutation hooks (Plan 01) for persistence, and add delete buttons to the annotation list.

Purpose: This is the integration plan that makes annotation editing actually work end-to-end. After this plan, all five ANNOT requirements are satisfied.
Output: Fully functional annotation editing in the sample detail modal -- move, resize, delete, and draw bounding boxes with DuckDB persistence.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-annotation-editing/10-RESEARCH.md
@.planning/phases/10-annotation-editing/10-01-SUMMARY.md
@.planning/phases/10-annotation-editing/10-02-SUMMARY.md

Key existing files:
@frontend/src/stores/ui-store.ts
@frontend/src/components/detail/sample-modal.tsx
@frontend/src/components/detail/annotation-list.tsx
@frontend/src/hooks/use-annotations.ts (now has mutation hooks from Plan 01)
@frontend/src/lib/coord-utils.ts (from Plan 02)
@frontend/src/components/detail/editable-rect.tsx (from Plan 02)
@frontend/src/components/detail/draw-layer.tsx (from Plan 02)
@frontend/src/components/detail/class-picker.tsx (from Plan 02)
@frontend/src/components/grid/annotation-overlay.tsx (SVG overlay -- reference)
@frontend/src/types/annotation.ts (Annotation, AnnotationUpdate, AnnotationCreate)
@frontend/src/lib/color-hash.ts (getClassColor, getSourceColor)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend UI store and build AnnotationEditor composition component</name>
  <files>
    frontend/src/stores/ui-store.ts
    frontend/src/components/detail/annotation-editor.tsx
  </files>
  <action>
    1. In `frontend/src/stores/ui-store.ts`, add to the UIState interface and create store:
       - `isEditMode: boolean` (default false) -- whether annotation editing is active
       - `selectedAnnotationId: string | null` (default null) -- which annotation is selected for resize/move
       - `isDrawMode: boolean` (default false) -- whether draw-new-box mode is active
       - `toggleEditMode: () => void` -- toggles isEditMode; when turning OFF, also resets selectedAnnotationId and isDrawMode to null/false
       - `setSelectedAnnotationId: (id: string | null) => void`
       - `toggleDrawMode: () => void` -- toggles isDrawMode; when turning ON, deselect annotation (selectedAnnotationId=null)
       - In the existing `closeDetailModal` action, also reset isEditMode=false, selectedAnnotationId=null, isDrawMode=false

    2. Create `frontend/src/components/detail/annotation-editor.tsx`:
       - "use client" directive

       Props interface `AnnotationEditorProps`:
       - `imageUrl`: string (full-resolution image URL)
       - `annotations`: Annotation[] (ground_truth only -- already filtered by parent)
       - `predictions`: Annotation[] (non-ground_truth -- read-only overlay)
       - `imageWidth`: number (original pixel width from sample)
       - `imageHeight`: number (original pixel height from sample)
       - `categories`: string[] (available category names for class picker)
       - `onUpdate`: `(id: string, bbox: { bbox_x: number; bbox_y: number; bbox_w: number; bbox_h: number }) => void`
       - `onCreate`: `(bbox: { bbox_x: number; bbox_y: number; bbox_w: number; bbox_h: number }, categoryName: string) => void`

       Implementation:
       a) Use `useImage` from "use-image" to load the image: `const [image, imageStatus] = useImage(imageUrl, "anonymous")`
       b) Use a container ref to measure available width: `const containerRef = useRef<HTMLDivElement>(null)` with a `useEffect` + `ResizeObserver` to track `containerWidth`. Default to 800 if not measured yet.
       c) Calculate display dimensions preserving aspect ratio:
          - `const aspectRatio = imageWidth / imageHeight`
          - `const displayWidth = containerWidth`
          - `const displayHeight = displayWidth / aspectRatio`
       d) Get scale factors: `const scale = getScaleFactors(imageWidth, imageHeight, displayWidth, displayHeight)`
       e) Read from UI store: `isEditMode`, `selectedAnnotationId`, `setSelectedAnnotationId`, `isDrawMode`
       f) Use the `useDrawLayer` hook from draw-layer.tsx for draw functionality
       g) State for class picker: `const [pendingRect, setPendingRect] = useState<{x,y,width,height}|null>(null)` -- set when draw completes, cleared when class is picked or cancelled

       Render structure:
       ```
       <div ref={containerRef} className="relative">
         {imageStatus === "loading" && <loading spinner>}
         <Stage width={displayWidth} height={displayHeight}
           onMouseDown={(e) => {
             // If draw mode, delegate to draw handlers
             if (isDrawMode) { drawHandlers.onMouseDown(e); return; }
             // Otherwise, deselect on empty area click
             if (e.target === e.target.getStage()) setSelectedAnnotationId(null);
           }}
           onMouseMove={isDrawMode ? drawHandlers.onMouseMove : undefined}
           onMouseUp={isDrawMode ? drawHandlers.onMouseUp : undefined}
         >
           <Layer>
             {/* Background image */}
             <Image image={image} width={displayWidth} height={displayHeight} />
           </Layer>
           <Layer>
             {/* Read-only prediction boxes (dashed, non-interactive) */}
             {predictions.map(ann => {
               const c = toCanvasCoords(ann, scale);
               return <Rect key={ann.id} x={c.x} y={c.y} width={c.width} height={c.height}
                 stroke={getSourceColor(ann.source)} strokeWidth={2}
                 dash={[8, 4]} fill="transparent" listening={false} />;
             })}
             {/* Editable ground truth boxes */}
             {annotations.map(ann => (
               <EditableRect
                 key={ann.id}
                 shapeProps={toCanvasCoords(ann, scale)}
                 stroke={getClassColor(ann.category_name)}
                 isSelected={selectedAnnotationId === ann.id}
                 onSelect={() => setSelectedAnnotationId(ann.id)}
                 onChange={(newAttrs) => {
                   const original = toOriginalCoords(newAttrs, scale);
                   onUpdate(ann.id, original);
                 }}
               />
             ))}
             {/* Draw preview rect */}
             {drawPreviewRect}
           </Layer>
         </Stage>
         {/* Class picker popup when a new box was just drawn */}
         {pendingRect && (
           <ClassPicker
             categories={categories}
             position={{ x: pendingRect.x, y: pendingRect.y }}
             onSelect={(categoryName) => {
               const original = toOriginalCoords(pendingRect, scale);
               onCreate(original, categoryName);
               setPendingRect(null);
             }}
             onCancel={() => setPendingRect(null)}
           />
         )}
       </div>
       ```

       The draw layer's onDrawComplete callback should set pendingRect (NOT immediately create the annotation -- need to pick a class first).

       IMPORTANT: Import react-konva components dynamically with `next/dynamic` and `ssr: false` because Konva requires `window`/`canvas`. The Stage, Layer, Image, and Rect must come from a dynamically imported module. Pattern:
       ```typescript
       import dynamic from "next/dynamic";
       const Stage = dynamic(() => import("react-konva").then(m => m.Stage), { ssr: false });
       ```
       Actually, the simpler pattern is to make the entire AnnotationEditor component dynamically imported in sample-modal.tsx. The component itself can use regular imports from react-konva since it will only be loaded client-side. Use `dynamic(() => import("./annotation-editor").then(m => ({ default: m.AnnotationEditor })), { ssr: false })` in sample-modal.tsx instead.
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes with the new component and store changes.
  </verify>
  <done>
    UI store has isEditMode, selectedAnnotationId, isDrawMode state and actions. AnnotationEditor composes Konva Stage with Image, prediction overlays, EditableRect components, draw layer, and class picker. All coordinate conversions use coord-utils.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AnnotationEditor into sample modal and add delete to annotation list</name>
  <files>
    frontend/src/components/detail/sample-modal.tsx
    frontend/src/components/detail/annotation-list.tsx
  </files>
  <action>
    1. In `frontend/src/components/detail/sample-modal.tsx`:

       a) Add imports:
          - `dynamic` from "next/dynamic"
          - `useUpdateAnnotation, useCreateAnnotation, useDeleteAnnotation` from "@/hooks/use-annotations"
          - `useUIStore` already imported -- add isEditMode, toggleEditMode, isDrawMode, toggleDrawMode selectors
          - `useFilterFacets` from "@/hooks/use-filter-facets" (to get available categories for the class picker)

       b) Dynamically import AnnotationEditor:
          ```typescript
          const AnnotationEditor = dynamic(
            () => import("./annotation-editor").then((m) => ({ default: m.AnnotationEditor })),
            { ssr: false, loading: () => <div className="flex items-center justify-center h-64">Loading editor...</div> }
          );
          ```

       c) Inside the SampleModal component:
          - Add store selectors: `const isEditMode = useUIStore(s => s.isEditMode)`, `const toggleEditMode = useUIStore(s => s.toggleEditMode)`, `const isDrawMode = useUIStore(s => s.isDrawMode)`, `const toggleDrawMode = useUIStore(s => s.toggleDrawMode)`
          - Instantiate mutation hooks (only when sample exists):
            ```typescript
            const updateMutation = useUpdateAnnotation(datasetId, selectedSampleId ?? "");
            const createMutation = useCreateAnnotation(datasetId, selectedSampleId ?? "");
            const deleteMutation = useDeleteAnnotation(datasetId, selectedSampleId ?? "");
            ```
          - Get categories from filter facets: `const { data: facets } = useFilterFacets(datasetId)` then extract categories: `const categories = facets?.categories ?? []`
          - Split annotations: `const gtAnnotations = (annotations ?? []).filter(a => a.source === "ground_truth")` and `const predAnnotations = (annotations ?? []).filter(a => a.source !== "ground_truth")`

       d) Replace the image+overlay section with conditional rendering:
          ```
          <div className="relative bg-zinc-100 dark:bg-zinc-800">
            {isEditMode ? (
              <AnnotationEditor
                imageUrl={fullImageUrl(datasetId, sample.id)}
                annotations={gtAnnotations}
                predictions={predAnnotations}
                imageWidth={sample.width}
                imageHeight={sample.height}
                categories={categories}
                onUpdate={(id, bbox) => updateMutation.mutate({ id, ...bbox })}
                onCreate={(bbox, categoryName) => createMutation.mutate({
                  dataset_id: datasetId,
                  sample_id: sample.id,
                  category_name: categoryName,
                  ...bbox,
                })}
              />
            ) : (
              <>
                <img src={fullImageUrl(datasetId, sample.id)} alt={sample.file_name}
                  className="h-auto w-full" decoding="async" />
                {annotations && annotations.length > 0 && (
                  <AnnotationOverlay annotations={annotations}
                    imageWidth={sample.width} imageHeight={sample.height} />
                )}
              </>
            )}
          </div>
          ```

       e) Add an edit toolbar between the image area and the metadata section:
          ```
          <div className="flex items-center gap-2 border-b border-zinc-200 px-5 py-2 dark:border-zinc-700">
            <button onClick={toggleEditMode}
              className={`rounded px-3 py-1.5 text-sm font-medium transition-colors ${
                isEditMode
                  ? "bg-blue-600 text-white hover:bg-blue-700"
                  : "bg-zinc-100 text-zinc-700 hover:bg-zinc-200 dark:bg-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"
              }`}>
              {isEditMode ? "Done" : "Edit Annotations"}
            </button>
            {isEditMode && (
              <button onClick={toggleDrawMode}
                className={`rounded px-3 py-1.5 text-sm font-medium transition-colors ${
                  isDrawMode
                    ? "bg-green-600 text-white hover:bg-green-700"
                    : "bg-zinc-100 text-zinc-700 hover:bg-zinc-200 dark:bg-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700"
                }`}>
                {isDrawMode ? "Cancel Draw" : "Draw New Box"}
              </button>
            )}
            {isEditMode && (
              <span className="ml-auto text-xs text-zinc-400">
                {isDrawMode ? "Click and drag to draw a new box" : "Click a box to select, drag to move, handles to resize"}
              </span>
            )}
          </div>
          ```

    2. In `frontend/src/components/detail/annotation-list.tsx`:

       a) Add `onDelete` to props: `onDelete?: (annotationId: string) => void`

       b) Add an "Actions" column header to the table (after Confidence)

       c) In each row, add a cell at the end:
          - If `ann.source === "ground_truth"` AND `onDelete` is provided: render a delete button (small red X or trash icon)
          - If ann.source !== "ground_truth": render an em-dash or empty cell
          - The delete button: small, red text/icon, with `onClick={() => onDelete(ann.id)}` and a title="Delete annotation"
          - Use a simple SVG trash icon or an X icon, styled with `text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300`

       d) Update the AnnotationList usage in sample-modal.tsx to pass onDelete:
          ```
          <AnnotationList
            annotations={annotations}
            onDelete={isEditMode ? (id) => deleteMutation.mutate(id) : undefined}
          />
          ```
          The delete column/buttons only appear when onDelete is provided (i.e., in edit mode).
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` passes
    - `cd frontend && npm run build` succeeds (verifies dynamic import works at build time)
    - Manually verify: open the app, click a sample, see the "Edit Annotations" button, click it, see Konva canvas replace the SVG overlay
  </verify>
  <done>
    Sample modal conditionally renders AnnotationEditor (edit mode) or SVG overlay (view mode). Edit toolbar with Edit/Done and Draw buttons appears. Mutation hooks connected: drag/resize calls PUT, draw calls POST, delete button calls DELETE. Annotation list shows delete buttons for ground_truth rows when in edit mode. Predictions are rendered as dashed non-interactive rectangles.
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npx tsc --noEmit` passes
- `cd frontend && npm run build` succeeds (no SSR issues with Konva)
- UI store: isEditMode toggles correctly, closeDetailModal resets edit state
- ANNOT-01: Drag a GT box -> PUT endpoint called -> box position persists after re-opening
- ANNOT-02: Resize a GT box via handles -> PUT endpoint called -> new size persists
- ANNOT-03: Click delete on a GT annotation row -> DELETE endpoint called -> annotation removed
- ANNOT-04: Enter draw mode, draw a box, pick a class -> POST endpoint called -> new annotation appears
- ANNOT-05: Prediction boxes are dashed, non-draggable, no Transformer, no delete button
</verification>

<success_criteria>
- Edit mode toggle button works in sample detail modal
- SVG overlay replaced by Konva canvas in edit mode, restored on exit
- Ground truth boxes are draggable with Transformer resize handles
- Prediction boxes are dashed, non-interactive (listening={false})
- Drag/resize calls PUT /annotations/{id} with original-space coordinates
- Draw new box -> class picker -> POST /annotations with category_name
- Delete button in annotation list -> DELETE /annotations/{id}
- All mutations invalidate caches so UI updates immediately
- No SSR errors (Konva loaded via dynamic import)
</success_criteria>

<output>
After completion, create `.planning/phases/10-annotation-editing/10-03-SUMMARY.md`
</output>
