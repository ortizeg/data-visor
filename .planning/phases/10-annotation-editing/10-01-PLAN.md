---
phase: 10-annotation-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/annotation.py
  - app/routers/annotations.py
  - app/main.py
  - frontend/src/lib/api.ts
  - frontend/src/types/annotation.ts
  - frontend/src/hooks/use-annotations.ts
autonomous: true

must_haves:
  truths:
    - "PUT /annotations/{id} updates bbox position and size for ground_truth annotations only"
    - "POST /annotations creates a new ground_truth annotation with generated UUID"
    - "DELETE /annotations/{id} removes a ground_truth annotation only"
    - "Non-ground_truth annotations cannot be modified or deleted via these endpoints"
    - "Frontend mutation hooks invalidate annotation and facet caches on success"
  artifacts:
    - path: "app/routers/annotations.py"
      provides: "Annotation CRUD router with PUT, POST, DELETE endpoints"
      exports: ["router"]
    - path: "app/models/annotation.py"
      provides: "AnnotationUpdate and AnnotationCreate Pydantic models"
      contains: "class AnnotationUpdate"
    - path: "frontend/src/lib/api.ts"
      provides: "apiPut helper function"
      contains: "export async function apiPut"
    - path: "frontend/src/types/annotation.ts"
      provides: "AnnotationUpdate and AnnotationCreate TypeScript types"
      contains: "export interface AnnotationUpdate"
    - path: "frontend/src/hooks/use-annotations.ts"
      provides: "useUpdateAnnotation, useCreateAnnotation, useDeleteAnnotation hooks"
      contains: "useUpdateAnnotation"
  key_links:
    - from: "frontend/src/hooks/use-annotations.ts"
      to: "/annotations/{id}"
      via: "apiPut, apiPost, apiDelete calls"
      pattern: "api(Put|Post|Delete).*annotations"
    - from: "app/routers/annotations.py"
      to: "annotations table"
      via: "DuckDB cursor SQL"
      pattern: "(UPDATE|INSERT|DELETE).*annotations.*WHERE.*source='ground_truth'"
    - from: "app/main.py"
      to: "app/routers/annotations.py"
      via: "include_router"
      pattern: "app\\.include_router\\(annotations\\.router\\)"
---

<objective>
Build the annotation CRUD data layer: backend REST endpoints (PUT/POST/DELETE) for ground_truth annotations with DuckDB persistence, plus frontend mutation hooks and TypeScript types.

Purpose: Establishes the data pipeline for all annotation editing operations (move, resize, delete, draw). Plans 02 and 03 build the visual editor on top of this data layer.
Output: Working API endpoints testable via curl, and React Query mutation hooks ready to wire into the Konva editor.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-annotation-editing/10-RESEARCH.md

Key existing files:
@app/models/annotation.py
@app/routers/samples.py (pattern reference for router structure)
@app/dependencies.py (get_db, get_cursor patterns)
@app/main.py (router registration)
@frontend/src/lib/api.ts (apiFetch, apiPost, apiPatch, apiDelete)
@frontend/src/types/annotation.ts (Annotation, BatchAnnotationsResponse)
@frontend/src/hooks/use-annotations.ts (useAnnotations, useAnnotationsBatch)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend annotation CRUD router and Pydantic models</name>
  <files>
    app/models/annotation.py
    app/routers/annotations.py
    app/main.py
  </files>
  <action>
    1. In `app/models/annotation.py`, add two new Pydantic models below the existing ones:
       - `AnnotationUpdate(BaseModel)` with fields: bbox_x (float), bbox_y (float), bbox_w (float), bbox_h (float)
       - `AnnotationCreate(BaseModel)` with fields: dataset_id (str), sample_id (str), category_name (str), bbox_x (float), bbox_y (float), bbox_w (float), bbox_h (float)

    2. Create `app/routers/annotations.py` following the same pattern as `app/routers/samples.py`:
       - `router = APIRouter(prefix="/annotations", tags=["annotations"])`
       - Use `get_cursor` from `app.dependencies` (NOT `get_db` + manual cursor). The `get_cursor` dependency yields a cursor and auto-closes it.

       Three endpoints:

       a) `PUT /{annotation_id}` -- Update bbox for a ground_truth annotation
          - Accept `AnnotationUpdate` body
          - Compute `area = body.bbox_w * body.bbox_h`
          - Execute: `UPDATE annotations SET bbox_x=?, bbox_y=?, bbox_w=?, bbox_h=?, area=? WHERE id=? AND source='ground_truth' RETURNING id`
          - If no row returned, raise HTTPException(404, "Annotation not found or not editable")
          - Return `{"updated": annotation_id}`

       b) `POST /` -- Create a new ground_truth annotation
          - Accept `AnnotationCreate` body
          - Generate ID: `str(uuid.uuid4())`
          - Compute `area = body.bbox_w * body.bbox_h`
          - INSERT into annotations with source='ground_truth', is_crowd=false, confidence=NULL
          - After insert, update the datasets table: `UPDATE datasets SET annotation_count = (SELECT COUNT(*) FROM annotations WHERE dataset_id=?), category_count = (SELECT COUNT(DISTINCT category_name) FROM annotations WHERE dataset_id=?) WHERE id=?`
          - Return `{"id": ann_id}`

       c) `DELETE /{annotation_id}` -- Delete a ground_truth annotation
          - First, SELECT dataset_id from the annotation before deletion (needed for count update)
          - Execute: `DELETE FROM annotations WHERE id=? AND source='ground_truth' RETURNING id, dataset_id`
          - If no row returned, raise HTTPException(404, "Annotation not found or not editable")
          - After delete, update datasets table counts (same as in POST)
          - Return `{"deleted": annotation_id}`

    3. In `app/main.py`:
       - Add `annotations` to the router imports line (existing import already imports multiple routers in one line)
       - Add `app.include_router(annotations.router)` after the ingestion router line
  </action>
  <verify>
    Run the FastAPI server and test with curl:
    - `curl -X PUT http://localhost:8000/annotations/test-id -H 'Content-Type: application/json' -d '{"bbox_x":10,"bbox_y":20,"bbox_w":100,"bbox_h":50}'` should return 404 (no such annotation)
    - Check that the /docs endpoint shows the 3 new annotation endpoints
    - Verify Python syntax: `python -c "from app.routers.annotations import router"`
  </verify>
  <done>
    Three annotation endpoints (PUT, POST, DELETE) registered and responding. PUT/DELETE enforce source='ground_truth' in their WHERE clauses. POST creates with source='ground_truth'. Dataset counts updated on create/delete.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend apiPut helper, mutation types, and mutation hooks</name>
  <files>
    frontend/src/lib/api.ts
    frontend/src/types/annotation.ts
    frontend/src/hooks/use-annotations.ts
  </files>
  <action>
    1. In `frontend/src/lib/api.ts`, add an `apiPut` function following the exact pattern of `apiPatch`:
       ```typescript
       export async function apiPut<T>(path: string, body: unknown): Promise<T> {
         const res = await fetch(`${API_BASE}${path}`, {
           method: "PUT",
           headers: { "Content-Type": "application/json" },
           body: JSON.stringify(body),
         });
         if (!res.ok) throw new Error(`API error: ${res.status} ${res.statusText}`);
         return res.json();
       }
       ```

    2. In `frontend/src/types/annotation.ts`, add these types after the existing interfaces:
       ```typescript
       /** Request body for PUT /annotations/{id} */
       export interface AnnotationUpdate {
         bbox_x: number;
         bbox_y: number;
         bbox_w: number;
         bbox_h: number;
       }

       /** Request body for POST /annotations */
       export interface AnnotationCreate {
         dataset_id: string;
         sample_id: string;
         category_name: string;
         bbox_x: number;
         bbox_y: number;
         bbox_w: number;
         bbox_h: number;
       }
       ```

    3. In `frontend/src/hooks/use-annotations.ts`, add three mutation hooks after the existing query hooks:
       - Import `useMutation, useQueryClient` from "@tanstack/react-query"
       - Import `apiPut, apiPost, apiDelete` from "@/lib/api"
       - Import `AnnotationUpdate, AnnotationCreate` from "@/types/annotation"

       a) `useUpdateAnnotation(datasetId: string, sampleId: string)`:
          - mutationFn: `({ id, ...bbox }: { id: string } & AnnotationUpdate) => apiPut<{ updated: string }>(`/annotations/${id}`, bbox)`
          - onSuccess: invalidate queryKeys ["annotations", sampleId, datasetId, ...] and ["annotations-batch"]
          - Note: The existing queryKey for useAnnotations is ["annotations", sampleId, datasetId, activeSources]. Use partial matching: `qc.invalidateQueries({ queryKey: ["annotations", sampleId] })` which matches any key starting with those elements.

       b) `useCreateAnnotation(datasetId: string, sampleId: string)`:
          - mutationFn: `(body: AnnotationCreate) => apiPost<{ id: string }>("/annotations", body)`
          - onSuccess: invalidate ["annotations", sampleId], ["annotations-batch"], and ["filter-facets", datasetId]

       c) `useDeleteAnnotation(datasetId: string, sampleId: string)`:
          - mutationFn: `(id: string) => apiDelete(`/annotations/${id}`)`
          - onSuccess: invalidate ["annotations", sampleId], ["annotations-batch"], and ["filter-facets", datasetId]

       Note: apiDelete returns void, so the mutation return type is void.
  </action>
  <verify>
    `cd frontend && npx tsc --noEmit` passes with no type errors.
  </verify>
  <done>
    apiPut helper exists in api.ts. AnnotationUpdate and AnnotationCreate types exist. Three mutation hooks (useUpdateAnnotation, useCreateAnnotation, useDeleteAnnotation) are exported and invalidate the correct cache keys on success.
  </done>
</task>

</tasks>

<verification>
- Backend: `python -c "from app.routers.annotations import router; print('OK')"` prints OK
- Backend: FastAPI /docs shows PUT /annotations/{id}, POST /annotations, DELETE /annotations/{id}
- Frontend: `cd frontend && npx tsc --noEmit` passes
- Mutation hooks import and reference correct API paths
</verification>

<success_criteria>
- Three REST endpoints for annotation CRUD registered in FastAPI
- PUT and DELETE enforce source='ground_truth' (predictions immutable)
- POST creates annotations as ground_truth with auto-generated UUID
- Dataset annotation_count and category_count updated on create/delete
- Frontend has apiPut, mutation types, and three mutation hooks
- All cache invalidation covers annotations, annotations-batch, and filter-facets
</success_criteria>

<output>
After completion, create `.planning/phases/10-annotation-editing/10-01-SUMMARY.md`
</output>
