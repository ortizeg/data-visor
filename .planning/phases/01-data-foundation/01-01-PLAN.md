---
phase: 01-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - app/__init__.py
  - app/main.py
  - app/config.py
  - app/dependencies.py
  - app/repositories/__init__.py
  - app/repositories/duckdb_repo.py
  - app/models/__init__.py
  - app/models/dataset.py
  - app/models/sample.py
  - app/models/annotation.py
  - tests/__init__.py
  - tests/conftest.py
  - .env.example
autonomous: true

must_haves:
  truths:
    - "FastAPI app starts with `uvicorn app.main:app` and responds to GET /health"
    - "DuckDB database file is created on startup with datasets, samples, annotations, and categories tables"
    - "DuckDB connection is managed via lifespan (single connection) with cursor-per-request dependency injection"
    - "Pydantic models exist for IngestRequest, DatasetResponse, SampleResponse, and PaginatedSamples"
  artifacts:
    - path: "app/main.py"
      provides: "FastAPI app factory with lifespan, CORS, router includes"
      contains: "lifespan"
    - path: "app/config.py"
      provides: "Pydantic Settings with env prefix VISIONLENS_"
      contains: "BaseSettings"
    - path: "app/dependencies.py"
      provides: "FastAPI dependency injection for DuckDB cursor, storage, image service"
      contains: "get_cursor"
    - path: "app/repositories/duckdb_repo.py"
      provides: "DuckDB connection wrapper with schema initialization"
      contains: "initialize_schema"
    - path: "app/models/dataset.py"
      provides: "IngestRequest and DatasetResponse Pydantic models"
      contains: "IngestRequest"
    - path: "pyproject.toml"
      provides: "Project definition with all Phase 1 dependencies"
      contains: "fastapi"
  key_links:
    - from: "app/main.py"
      to: "app/repositories/duckdb_repo.py"
      via: "lifespan creates DuckDBRepo and stores on app.state"
      pattern: "app\\.state\\.db"
    - from: "app/dependencies.py"
      to: "app/repositories/duckdb_repo.py"
      via: "get_db reads from request.app.state, get_cursor creates cursor"
      pattern: "request\\.app\\.state\\.db"
---

<objective>
Set up the VisionLens Python project with FastAPI, DuckDB connection management, schema creation, Pydantic data models, and test infrastructure.

Purpose: This is the foundation every other plan depends on -- the runnable app skeleton, database layer, and shared types that the parser, storage, plugin, and API plans will import.
Output: A FastAPI app that starts, creates a DuckDB database with the correct schema, and provides dependency injection for all subsequent plans. Pydantic models define the data contracts.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Python project with uv and install all Phase 1 dependencies</name>
  <files>pyproject.toml, .env.example</files>
  <action>
    Initialize the project using `uv init` (or manually create pyproject.toml if uv init conflicts with existing directory).

    Add all dependencies via uv:
    - Core: fastapi, uvicorn[standard], duckdb, pydantic, pydantic-settings
    - Ingestion: ijson, pandas
    - Image processing: Pillow
    - Cloud storage: gcsfs, fsspec
    - Dev: pytest, pytest-asyncio, httpx, ruff

    Create `.env.example` with all VISIONLENS_ prefixed env vars documented:
    - VISIONLENS_DB_PATH=data/visionlens.duckdb
    - VISIONLENS_THUMBNAIL_CACHE_DIR=data/thumbnails
    - VISIONLENS_PLUGIN_DIR=plugins
    - VISIONLENS_HOST=0.0.0.0
    - VISIONLENS_PORT=8000
    - VISIONLENS_GCS_CREDENTIALS_PATH= (optional, empty default)

    Create the `app/` package directory with `__init__.py`, and create subdirectory stubs:
    - app/routers/__init__.py
    - app/services/__init__.py
    - app/repositories/__init__.py
    - app/ingestion/__init__.py
    - app/plugins/__init__.py
    - app/models/__init__.py

    Create `tests/__init__.py`.

    Do NOT use `uv init` if it would overwrite .git or existing files. Instead, manually create pyproject.toml with the correct structure and run `uv add` commands.
  </action>
  <verify>
    Run `uv sync` to verify all dependencies install cleanly.
    Run `python -c "import fastapi; import duckdb; import ijson; import PIL; import fsspec; print('OK')"` to verify imports.
  </verify>
  <done>pyproject.toml exists with all Phase 1 dependencies. `uv sync` succeeds. All core imports work. Package directories exist with __init__.py files.</done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI app, DuckDB repository with schema, config, dependencies, and Pydantic models</name>
  <files>app/main.py, app/config.py, app/dependencies.py, app/repositories/duckdb_repo.py, app/models/dataset.py, app/models/sample.py, app/models/annotation.py, tests/conftest.py</files>
  <action>
    **app/config.py:** Create Pydantic Settings class with fields:
    - db_path: Path = Path("data/visionlens.duckdb")
    - thumbnail_cache_dir: Path = Path("data/thumbnails")
    - thumbnail_default_size: str = "medium"
    - thumbnail_webp_quality: int = 80
    - plugin_dir: Path = Path("plugins")
    - host: str = "0.0.0.0"
    - port: int = 8000
    - gcs_credentials_path: str | None = None
    - Use env_prefix="VISIONLENS_" and env_file=".env"
    - Include a module-level `get_settings()` function with caching (global singleton pattern from research)

    **app/repositories/duckdb_repo.py:** Create DuckDBRepo class:
    - `__init__(self, db_path: str | Path)`: Opens duckdb.connect(str(db_path)), sets PRAGMA threads=4
    - `initialize_schema(self)`: Creates 4 tables IF NOT EXISTS:
      - datasets: id VARCHAR NOT NULL, name VARCHAR NOT NULL, format VARCHAR NOT NULL, source_path VARCHAR NOT NULL, image_dir VARCHAR NOT NULL, image_count INTEGER DEFAULT 0, annotation_count INTEGER DEFAULT 0, category_count INTEGER DEFAULT 0, created_at TIMESTAMP DEFAULT current_timestamp, metadata JSON
      - samples: id VARCHAR NOT NULL, dataset_id VARCHAR NOT NULL, file_name VARCHAR NOT NULL, width INTEGER NOT NULL, height INTEGER NOT NULL, thumbnail_path VARCHAR, split VARCHAR, metadata JSON
      - annotations: id VARCHAR NOT NULL, dataset_id VARCHAR NOT NULL, sample_id VARCHAR NOT NULL, category_name VARCHAR NOT NULL, bbox_x DOUBLE NOT NULL, bbox_y DOUBLE NOT NULL, bbox_w DOUBLE NOT NULL, bbox_h DOUBLE NOT NULL, area DOUBLE DEFAULT 0.0, is_crowd BOOLEAN DEFAULT false, source VARCHAR DEFAULT 'ground_truth', confidence DOUBLE, metadata JSON
      - categories: dataset_id VARCHAR NOT NULL, category_id INTEGER NOT NULL, name VARCHAR NOT NULL, supercategory VARCHAR
    - NO PRIMARY KEY or FOREIGN KEY constraints (3.8x faster bulk inserts per research)
    - `close(self)`: Closes connection
    - Ensure the parent directory of db_path is created (Path(db_path).parent.mkdir(parents=True, exist_ok=True)) before connect

    **app/dependencies.py:** Create FastAPI dependency functions:
    - `get_db(request: Request) -> DuckDBRepo`: Returns request.app.state.db
    - `get_cursor(db = Depends(get_db))`: Generator that creates cursor, yields it, closes in finally block
    - Placeholder stubs for `get_storage()` and `get_image_service()` that raise NotImplementedError (Plan 03 will implement)

    **app/main.py:** Create FastAPI app with lifespan:
    - Lifespan: Create DuckDBRepo from settings.db_path, call initialize_schema(), store on app.state.db. On shutdown, call db.close().
    - Add CORS middleware (allow all origins for dev -- will restrict later)
    - Add GET /health endpoint returning {"status": "ok"}
    - Include router placeholders (commented out) for datasets, samples, images

    **app/models/dataset.py:** Pydantic models:
    - IngestRequest: annotation_path (str), image_dir (str), dataset_name (str | None = None), format (str = "coco")
    - DatasetResponse: id, name, format, source_path, image_dir, image_count, annotation_count, category_count, created_at (datetime)
    - DatasetListResponse: datasets (list[DatasetResponse])

    **app/models/sample.py:** Pydantic models:
    - SampleResponse: id, dataset_id, file_name, width, height, thumbnail_path (str | None), split (str | None)
    - SampleFilter: dataset_id (str), category (str | None = None), split (str | None = None), min_width (int | None = None), min_height (int | None = None)
    - PaginatedSamples: items (list[SampleResponse]), total (int), offset (int), limit (int)

    **app/models/annotation.py:** Pydantic models:
    - AnnotationResponse: id, dataset_id, sample_id, category_name, bbox_x, bbox_y, bbox_w, bbox_h, area, is_crowd, source, confidence (float | None)
    - BBox: x (float), y (float), w (float), h (float) -- utility model

    **tests/conftest.py:** Create pytest fixtures:
    - `tmp_db_path(tmp_path)`: Returns a temporary DuckDB file path
    - `db(tmp_db_path)`: Creates DuckDBRepo with test path, initializes schema, yields, closes
    - `app_client(db, tmp_path)`: Creates FastAPI test app with the test DB, yields httpx.AsyncClient
    - Mark async fixtures with `@pytest.fixture` and use `pytest.mark.asyncio`
  </action>
  <verify>
    Run `uv run uvicorn app.main:app --host 0.0.0.0 --port 8000` -- app should start and log "Uvicorn running".
    Run `curl http://localhost:8000/health` -- should return {"status":"ok"}.
    Run `uv run python -c "from app.repositories.duckdb_repo import DuckDBRepo; db = DuckDBRepo('/tmp/test.duckdb'); db.initialize_schema(); print(db.connection.execute('SHOW TABLES').fetchall()); db.close()"` -- should show 4 tables.
    Run `uv run pytest tests/ -x` -- conftest fixtures should load without errors (even if no test files yet, pytest should collect 0 tests with no errors).
  </verify>
  <done>
    FastAPI app starts on port 8000 and responds to /health. DuckDB creates datasets, samples, annotations, categories tables on startup. Dependency injection provides cursor-per-request. All Pydantic models importable. Test fixtures work.
  </done>
</task>

</tasks>

<verification>
1. `uv sync` installs all dependencies without errors
2. `uv run uvicorn app.main:app --port 8000` starts the server
3. `curl localhost:8000/health` returns `{"status":"ok"}`
4. DuckDB file is created at the configured path with 4 tables
5. `uv run pytest tests/ -x` runs without fixture errors
6. `uv run python -c "from app.models.dataset import IngestRequest; print(IngestRequest.model_json_schema())"` outputs valid JSON schema
</verification>

<success_criteria>
- FastAPI application starts and serves /health endpoint
- DuckDB database is created with datasets, samples, annotations, categories tables (no PK/FK constraints)
- Pydantic models define the data contracts for ingestion, datasets, samples, and annotations
- Dependency injection wired for DuckDB cursor-per-request
- Test infrastructure ready with conftest fixtures
- All Phase 1 Python dependencies installed and importable
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-01-SUMMARY.md`
</output>
