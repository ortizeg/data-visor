---
phase: 01-data-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/plugins/base_plugin.py
  - app/plugins/registry.py
  - app/plugins/hooks.py
  - plugins/example_plugin/__init__.py
  - tests/test_plugins.py
autonomous: true

must_haves:
  truths:
    - "A BasePlugin Python class exists with defined extension points that a developer can subclass"
    - "Plugins are discovered from a directory and loaded dynamically at startup"
    - "Plugin hook invocations are isolated -- a failing plugin does not crash the application"
    - "All plugin hooks use keyword-only arguments with a PluginContext dataclass"
  artifacts:
    - path: "app/plugins/base_plugin.py"
      provides: "BasePlugin ABC with ingestion and lifecycle hooks, PluginContext dataclass"
      contains: "class BasePlugin"
    - path: "app/plugins/registry.py"
      provides: "PluginRegistry with discover_plugins, trigger_hook, get_plugin"
      contains: "class PluginRegistry"
    - path: "app/plugins/hooks.py"
      provides: "Hook name constants and HookSpec definitions"
      contains: "HOOK_"
    - path: "plugins/example_plugin/__init__.py"
      provides: "Working example plugin subclassing BasePlugin"
      contains: "class ExamplePlugin"
    - path: "tests/test_plugins.py"
      provides: "Tests for plugin discovery, loading, hook invocation, and error isolation"
      contains: "test_"
  key_links:
    - from: "app/plugins/registry.py"
      to: "app/plugins/base_plugin.py"
      via: "PluginRegistry discovers and instantiates BasePlugin subclasses"
      pattern: "issubclass.*BasePlugin"
    - from: "app/plugins/registry.py"
      to: "app/plugins/hooks.py"
      via: "trigger_hook validates hook names against defined constants"
      pattern: "trigger_hook"
    - from: "plugins/example_plugin/__init__.py"
      to: "app/plugins/base_plugin.py"
      via: "ExamplePlugin subclasses BasePlugin and overrides hooks"
      pattern: "class ExamplePlugin\\(BasePlugin\\)"
---

<objective>
Build the plugin system: BasePlugin abstract class, PluginContext dataclass, HookRegistry for discovery and invocation, and an example plugin proving the contract works.

Purpose: PLUGIN-01 requirement. The plugin system must exist from v1. Ingestion hooks allow users to intercept and transform data during import. This plan is independent of the database/API work and can execute in parallel with Plan 01.
Output: A complete, tested plugin subsystem that Plan 04 will wire into the ingestion pipeline.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BasePlugin ABC, PluginContext, and hook definitions</name>
  <files>app/plugins/base_plugin.py, app/plugins/hooks.py</files>
  <action>
    **app/plugins/base_plugin.py:** Create the plugin contract:

    1. `PluginContext` dataclass with keyword-only fields:
       - dataset_id: str
       - metadata: dict[str, Any] | None = None
       This is the extensible context object passed to all hooks. Future phases add fields without breaking existing plugins.

    2. `BasePlugin` ABC with:
       - `api_version: int = 1` (class variable for future compatibility checking)
       - `name` property (abstract, must return unique string)
       - `description` property (optional, default empty string)
       - Ingestion hooks (all keyword-only args, all optional -- override only what you need):
         - `on_ingest_start(self, *, context: PluginContext) -> None`
         - `on_sample_ingested(self, *, context: PluginContext, sample: dict) -> dict` (return modified or original sample)
         - `on_ingest_complete(self, *, context: PluginContext, stats: dict) -> None`
       - Lifecycle hooks:
         - `on_activate(self) -> None`
         - `on_deactivate(self) -> None`
       - All non-abstract hooks have default no-op implementations (pass or return input).
       - `on_sample_ingested` default returns `sample` unchanged.

    **app/plugins/hooks.py:** Define hook constants and types:
    - HOOK_INGEST_START = "on_ingest_start"
    - HOOK_SAMPLE_INGESTED = "on_sample_ingested"
    - HOOK_INGEST_COMPLETE = "on_ingest_complete"
    - HOOK_ACTIVATE = "on_activate"
    - HOOK_DEACTIVATE = "on_deactivate"
    - ALL_HOOKS: list[str] = [all of the above]
    - This centralizes hook names so registry and tests reference constants, not magic strings.

    IMPORTANT: Use keyword-only arguments on ALL hooks (the `*` separator). This prevents breakage when new parameters are added in future versions. This is an anti-pattern from research -- positional args break all plugins when you add a parameter.
  </action>
  <verify>
    Run `uv run python -c "from app.plugins.base_plugin import BasePlugin, PluginContext; from app.plugins.hooks import ALL_HOOKS; print(f'BasePlugin hooks: {ALL_HOOKS}')"` -- should print all hook names.
    Verify BasePlugin cannot be instantiated directly (it's abstract due to `name` property).
  </verify>
  <done>BasePlugin ABC exists with 5 hooks (3 ingestion, 2 lifecycle). PluginContext dataclass exists. Hook constants defined. All hooks use keyword-only arguments.</done>
</task>

<task type="auto">
  <name>Task 2: Create PluginRegistry, example plugin, and plugin tests</name>
  <files>app/plugins/registry.py, plugins/example_plugin/__init__.py, tests/test_plugins.py</files>
  <action>
    **app/plugins/registry.py:** Create PluginRegistry class:

    1. `__init__(self)`: Initialize `_plugins: dict[str, BasePlugin]` (name -> instance)

    2. `discover_plugins(self, plugin_dir: Path) -> list[str]`:
       - If plugin_dir doesn't exist, return empty list (don't crash)
       - Iterate subdirectories that contain `__init__.py`
       - Use `importlib.util.spec_from_file_location` and `module_from_spec` to load each module
       - Scan module attributes for BasePlugin subclasses (not BasePlugin itself)
       - Instantiate each, store in _plugins dict, call `on_activate()`
       - Wrap entire per-plugin discovery in try/except -- log errors but continue
       - Return list of discovered plugin names

    3. `register_plugin(self, plugin: BasePlugin) -> None`:
       - Manual registration (for testing). Stores plugin, calls on_activate().

    4. `trigger_hook(self, hook_name: str, **kwargs) -> list[Any]`:
       - Iterate all registered plugins
       - Get the hook method via getattr (return None if missing)
       - Call hook with **kwargs inside try/except
       - Collect and return results (list of return values)
       - On exception: log error with plugin name and hook name, continue to next plugin
       - CRITICAL: Never let a plugin exception propagate. Plugins are untrusted code.

    5. `get_plugin(self, name: str) -> BasePlugin | None`: Lookup by name.

    6. `list_plugins(self) -> list[str]`: Return registered plugin names.

    7. `shutdown(self)`: Call on_deactivate() on all plugins (wrapped in try/except).

    **plugins/example_plugin/__init__.py:** Create a working example:
    - `ExamplePlugin(BasePlugin)` that:
      - name = "example"
      - description = "Example plugin demonstrating the hook API"
      - on_ingest_start: logs/prints "Example plugin: ingestion starting for {context.dataset_id}"
      - on_sample_ingested: adds a "processed_by_example" key to sample dict, returns it
      - on_ingest_complete: logs/prints stats summary

    **tests/test_plugins.py:** Write comprehensive tests:
    1. `test_base_plugin_cannot_instantiate`: Verify BasePlugin raises TypeError
    2. `test_plugin_context_creation`: Verify PluginContext fields
    3. `test_example_plugin_hooks`: Create ExamplePlugin, call each hook, verify behavior
    4. `test_on_sample_ingested_returns_modified`: Verify sample dict is modified by example plugin
    5. `test_registry_discover_plugins`: Point registry at plugins/ dir, verify example plugin is found
    6. `test_registry_trigger_hook`: Register example plugin, trigger hooks, verify results
    7. `test_registry_isolates_plugin_errors`: Create a plugin that raises in a hook, register alongside example plugin. Trigger hook -- example plugin should still execute, no exception propagates.
    8. `test_registry_empty_dir`: discover_plugins on empty/nonexistent dir returns empty list
    9. `test_registry_shutdown`: Verify on_deactivate is called for all plugins

    Use `tmp_path` fixture for temporary plugin directories in tests. For the error isolation test, create an inline FaultyPlugin class that raises RuntimeError in on_ingest_start.
  </action>
  <verify>
    Run `uv run pytest tests/test_plugins.py -v` -- all tests pass.
    Run `uv run python -c "
from pathlib import Path
from app.plugins.registry import PluginRegistry
reg = PluginRegistry()
found = reg.discover_plugins(Path('plugins'))
print(f'Discovered: {found}')
"` -- should print "Discovered: ['example']".
  </verify>
  <done>PluginRegistry discovers and loads plugins from directory. Hook invocations are error-isolated. Example plugin demonstrates all hook types. All 9+ tests pass.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_plugins.py -v` -- all tests pass
2. BasePlugin cannot be directly instantiated (abstract name property)
3. PluginRegistry discovers ExamplePlugin from plugins/ directory
4. trigger_hook("on_ingest_start", context=PluginContext(dataset_id="test")) succeeds
5. A plugin that raises an exception does not crash trigger_hook -- other plugins still execute
6. on_sample_ingested returns modified sample dict (not None)
</verification>

<success_criteria>
- BasePlugin ABC with 5 hooks (3 ingestion, 2 lifecycle) using keyword-only arguments
- PluginContext dataclass for extensible hook context
- PluginRegistry with discover, trigger, and error isolation
- Example plugin proves the contract works end-to-end
- All tests pass including error isolation test
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
