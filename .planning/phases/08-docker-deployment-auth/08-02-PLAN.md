---
phase: 08-docker-deployment-auth
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile.frontend
  - frontend/next.config.ts
  - Caddyfile
autonomous: true

must_haves:
  truths:
    - "Frontend Docker image builds successfully with standalone Next.js output"
    - "Caddy is configured to proxy /api/* to backend and /* to frontend with basic auth"
    - "NEXT_PUBLIC_API_URL=/api is baked into the frontend build for same-origin API calls"
  artifacts:
    - path: "Dockerfile.frontend"
      provides: "Multi-stage Next.js standalone Docker build"
      contains: "output.*standalone"
    - path: "frontend/next.config.ts"
      provides: "Standalone output configuration for Docker"
      contains: "standalone"
    - path: "Caddyfile"
      provides: "Reverse proxy with basic auth and route splitting"
      contains: "basic_auth"
  key_links:
    - from: "Caddyfile"
      to: "backend:8000"
      via: "reverse_proxy for /api/* routes"
      pattern: "reverse_proxy backend:8000"
    - from: "Caddyfile"
      to: "frontend:3000"
      via: "reverse_proxy for all other routes"
      pattern: "reverse_proxy frontend:3000"
    - from: "Dockerfile.frontend"
      to: "frontend/next.config.ts"
      via: "next build reads standalone output config"
      pattern: "npm run build"
---

<objective>
Create the frontend Docker image and Caddy reverse proxy configuration.

Purpose: The frontend Dockerfile produces a minimal standalone Next.js image (~150MB vs ~1GB). The Caddyfile is the single entry point for all traffic, handling auth, HTTPS, and routing -- zero application code changes needed for authentication.
Output: Dockerfile.frontend, updated frontend/next.config.ts, Caddyfile
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-docker-deployment-auth/08-RESEARCH.md

@frontend/next.config.ts
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage frontend Dockerfile and update next.config.ts</name>
  <files>Dockerfile.frontend, frontend/next.config.ts</files>
  <action>
**Update `frontend/next.config.ts`:**
Add `output: "standalone"` to the nextConfig object. This tells Next.js to produce a self-contained `server.js` with only necessary dependencies, critical for Docker image optimization.

```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: "standalone",
  images: {
    unoptimized: true,
  },
};

export default nextConfig;
```

**Create `Dockerfile.frontend` at project root** (NOT inside frontend/) with a three-stage build:

**Stage 1 (deps):**
- Base: `node:22-alpine`
- WORKDIR `/app`
- Copy `frontend/package.json` and `frontend/package-lock.json` (use the paths relative to build context which is project root)
- Actually: since docker-compose sets `context: ./frontend`, copy `package.json` and `package-lock.json` directly.
- Wait -- the research shows `context: ./frontend` and `dockerfile: ../Dockerfile.frontend`. That means the build context IS the frontend directory. So paths in the Dockerfile are relative to `frontend/`.
- Copy `package.json` and `package-lock.json`
- Run `npm ci`

**Stage 2 (builder):**
- Base: `node:22-alpine`
- WORKDIR `/app`
- Copy `node_modules` from deps stage
- Copy all frontend source: `COPY . .`
- Set build arg and env: `ARG NEXT_PUBLIC_API_URL=/api` and `ENV NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL`
- Run `npm run build`

**Stage 3 (runner):**
- Base: `node:22-alpine`
- WORKDIR `/app`
- Set `ENV NODE_ENV=production`
- Create non-root user: `RUN addgroup --system --gid 1001 nodejs && adduser --system --uid 1001 nextjs`
- Copy `public/` from builder (if it exists -- check if frontend has a public dir)
- Copy `.next/standalone` from builder with chown to nextjs:nodejs
- Copy `.next/static` from builder to `.next/static` with chown to nextjs:nodejs
- Set `USER nextjs`
- EXPOSE 3000
- Set `ENV PORT=3000` and `ENV HOSTNAME=0.0.0.0`
- CMD: `["node", "server.js"]`

CRITICAL: `NEXT_PUBLIC_API_URL=/api` MUST be set at build time via ARG/ENV, NOT at runtime. Next.js inlines NEXT_PUBLIC_* vars into the JS bundle during `next build`. Runtime env vars have zero effect.

The `/api` value means all frontend API calls go to the same origin (e.g., `http://localhost/api/datasets`), and Caddy strips `/api` prefix before forwarding to the backend.
  </action>
  <verify>Run `docker build -f Dockerfile.frontend -t datavisor-frontend ./frontend` from project root and confirm it builds successfully. Verify image size is reasonable (~150-200MB).</verify>
  <done>Dockerfile.frontend exists at project root, builds successfully with standalone output. frontend/next.config.ts includes `output: "standalone"`. NEXT_PUBLIC_API_URL=/api is baked in at build time.</done>
</task>

<task type="auto">
  <name>Task 2: Create Caddyfile reverse proxy configuration</name>
  <files>Caddyfile</files>
  <action>
Create `Caddyfile` at project root with this configuration:

```
{$DOMAIN:localhost} {
    basic_auth {
        {$AUTH_USERNAME:admin} {$AUTH_PASSWORD_HASH}
    }

    handle /api/* {
        uri strip_prefix /api
        reverse_proxy backend:8000
    }

    handle {
        reverse_proxy frontend:3000
    }
}
```

Key details:
- `{$DOMAIN:localhost}` uses Caddy's env variable syntax with fallback. When `DOMAIN=yourdomain.com` is set, Caddy auto-provisions HTTPS via Let's Encrypt. When unset/localhost, it serves HTTP only.
- `basic_auth` block protects ALL routes (both API and frontend). The browser's native Basic Auth dialog prompts the user. This covers SSE endpoints too since Caddy authenticates the HTTP connection before it reaches FastAPI.
- `{$AUTH_USERNAME:admin}` defaults to "admin" if env var unset.
- `{$AUTH_PASSWORD_HASH}` is a bcrypt hash (no default -- must be set or Caddy will error, which is intentional to prevent running without auth).
- `uri strip_prefix /api` removes the `/api` prefix before forwarding to backend, so backend sees `/datasets` not `/api/datasets`.
- The `handle` directive ordering matters: specific paths first (`/api/*`), then catch-all. Caddy's `handle` is mutually exclusive (first match wins).
- SSE streams (`text/event-stream`) are auto-flushed by Caddy -- no `flush_interval` config needed.

Do NOT expose backend (8000) or frontend (3000) ports directly. All traffic goes through Caddy on 80/443.
  </action>
  <verify>Run `docker run --rm -v "$(pwd)/Caddyfile:/etc/caddy/Caddyfile:ro" caddy:2-alpine caddy validate --config /etc/caddy/Caddyfile` to validate the Caddyfile syntax (may warn about missing env vars but should not error on syntax). Alternatively, confirm the file exists and has the expected directives.</verify>
  <done>Caddyfile exists at project root with basic_auth, /api/* reverse proxy to backend:8000 (with uri strip_prefix), and catch-all reverse proxy to frontend:3000. Uses environment variables for DOMAIN, AUTH_USERNAME, and AUTH_PASSWORD_HASH.</done>
</task>

</tasks>

<verification>
1. `docker build -f Dockerfile.frontend -t datavisor-frontend ./frontend` completes successfully
2. `frontend/next.config.ts` contains `output: "standalone"`
3. Caddyfile contains `basic_auth`, `reverse_proxy backend:8000`, and `reverse_proxy frontend:3000`
4. Caddyfile uses `{$DOMAIN:localhost}`, `{$AUTH_USERNAME:admin}`, `{$AUTH_PASSWORD_HASH}` env vars
</verification>

<success_criteria>
- Frontend Docker image builds with standalone Next.js output and /api base URL baked in
- Caddyfile routes /api/* to backend and /* to frontend with basic auth on all routes
- No application code changes needed for authentication (Caddy handles it at proxy layer)
</success_criteria>

<output>
After completion, create `.planning/phases/08-docker-deployment-auth/08-02-SUMMARY.md`
</output>
