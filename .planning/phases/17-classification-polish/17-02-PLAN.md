---
phase: 17-classification-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/reduction_service.py
  - app/routers/embeddings.py
  - frontend/src/types/embedding.ts
  - frontend/src/components/embedding/embedding-scatter.tsx
  - frontend/src/components/embedding/embedding-panel.tsx
  - frontend/src/app/datasets/[datasetId]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can select color mode (Default, GT Class, Predicted Class, Correct/Incorrect) in embedding toolbar"
    - "Embedding scatter points change color based on selected color mode"
    - "Color mode dropdown options for Predicted Class and Correct/Incorrect are disabled when no predictions exist"
    - "Backend coordinates endpoint returns gtLabel and predLabel per point"
  artifacts:
    - path: "app/services/reduction_service.py"
      provides: "Enriched get_coordinates with GT/pred label JOINs"
      contains: "gt_label"
    - path: "frontend/src/types/embedding.ts"
      provides: "gtLabel and predLabel fields on EmbeddingPoint"
      contains: "gtLabel"
    - path: "frontend/src/components/embedding/embedding-scatter.tsx"
      provides: "colorMode-driven getFillColor with categorical palette"
      contains: "colorMode"
    - path: "frontend/src/components/embedding/embedding-panel.tsx"
      provides: "Color mode dropdown in toolbar"
      contains: "ColorMode"
  key_links:
    - from: "frontend/src/components/embedding/embedding-panel.tsx"
      to: "frontend/src/components/embedding/embedding-scatter.tsx"
      via: "colorMode prop"
      pattern: "colorMode"
    - from: "app/services/reduction_service.py"
      to: "frontend/src/types/embedding.ts"
      via: "API response shape includes gtLabel, predLabel"
      pattern: "gtLabel"
    - from: "frontend/src/app/datasets/[datasetId]/page.tsx"
      to: "frontend/src/components/embedding/embedding-panel.tsx"
      via: "datasetType prop threading"
      pattern: "datasetType"
---

<objective>
Add embedding scatter color modes (GT Class, Predicted Class, Correct/Incorrect) by enriching the backend coordinates endpoint with annotation labels and building a color mode dropdown with categorical palette in the frontend.

Purpose: Let users instantly see how embedding clusters correlate with class labels and prediction correctness, surfacing misclassification patterns spatially.
Output: Enriched coordinates API, color mode dropdown in embedding toolbar, categorical coloring in scatter plot.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-classification-polish/17-RESEARCH.md
@app/services/reduction_service.py
@app/routers/embeddings.py
@frontend/src/types/embedding.ts
@frontend/src/components/embedding/embedding-scatter.tsx
@frontend/src/components/embedding/embedding-panel.tsx
@frontend/src/app/datasets/[datasetId]/page.tsx
@frontend/src/hooks/use-embeddings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend coordinates enrichment with GT/pred labels</name>
  <files>
    app/services/reduction_service.py
    app/routers/embeddings.py
    frontend/src/types/embedding.ts
  </files>
  <action>
**1. Enrich `get_coordinates` in reduction_service.py:**

Modify the SQL query to LEFT JOIN annotations for GT and predicted labels. Use MIN() + GROUP BY to handle multi-annotation edge cases (collapse to one label per sample):

```python
def get_coordinates(self, dataset_id: str, cursor) -> list[dict]:
    result = cursor.execute(
        """
        SELECT e.sample_id, e.x, e.y, s.file_name, s.thumbnail_path,
               MIN(gt.category_name) as gt_label,
               MIN(pred.category_name) as pred_label
        FROM embeddings e
        JOIN samples s ON e.sample_id = s.id AND e.dataset_id = s.dataset_id
        LEFT JOIN annotations gt ON gt.sample_id = s.id AND gt.dataset_id = s.dataset_id
            AND gt.source = 'ground_truth'
        LEFT JOIN annotations pred ON pred.sample_id = s.id AND pred.dataset_id = s.dataset_id
            AND pred.source != 'ground_truth'
        WHERE e.dataset_id = ? AND e.x IS NOT NULL
        GROUP BY e.sample_id, e.x, e.y, s.file_name, s.thumbnail_path
        ORDER BY e.sample_id
        """,
        [dataset_id],
    ).fetchall()
    return [
        {
            "sampleId": r[0],
            "x": r[1],
            "y": r[2],
            "fileName": r[3],
            "thumbnailPath": r[4],
            "gtLabel": r[5],
            "predLabel": r[6],
        }
        for r in result
    ]
```

Keep the method signature the same (dataset_id, cursor). The LEFT JOINs ensure points without annotations still appear (gtLabel/predLabel will be null). The MIN() + GROUP BY prevents duplicate rows from multi-source predictions or multi-label GT.

The router endpoint `get_coordinates` in embeddings.py needs NO changes -- it already returns `list[dict]` and just calls `reduction_service.get_coordinates(dataset_id, cursor)`.

**2. Update EmbeddingPoint type in frontend/src/types/embedding.ts:**

Add two optional fields to the `EmbeddingPoint` interface:

```typescript
export interface EmbeddingPoint {
  sampleId: string;
  x: number;
  y: number;
  fileName: string;
  thumbnailPath: string | null;
  gtLabel?: string | null;
  predLabel?: string | null;
}
```

Make them optional (`?`) so existing code that doesn't use them continues to work without changes.
  </action>
  <verify>
Run `cd frontend && npx tsc --noEmit` to confirm the type change doesn't break existing usages.
Run `python -c "import app.services.reduction_service; print('OK')"` to confirm the module loads.
  </verify>
  <done>
Backend coordinates endpoint returns gtLabel and predLabel per point (null when no annotations exist). EmbeddingPoint type updated with optional gtLabel/predLabel fields. No breakage to existing consumers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Embedding scatter color mode dropdown and categorical coloring</name>
  <files>
    frontend/src/components/embedding/embedding-scatter.tsx
    frontend/src/components/embedding/embedding-panel.tsx
    frontend/src/app/datasets/[datasetId]/page.tsx
  </files>
  <action>
**1. Add colorMode prop to EmbeddingScatter (embedding-scatter.tsx):**

Add a `colorMode` prop to EmbeddingScatterProps:

```typescript
type ColorMode = "default" | "gt_class" | "pred_class" | "correctness";

interface EmbeddingScatterProps {
  points: EmbeddingPoint[];
  onHover?: (...) => void;
  selectedIds?: string[] | null;
  deckRef?: React.RefObject<DeckGLRef | null>;
  colorMode?: ColorMode;
}
```

Export the `ColorMode` type for use in embedding-panel.tsx.

Define a categorical color palette (20 distinct RGBA colors, based on Tableau 20):

```typescript
const CATEGORICAL_PALETTE: [number,number,number,number][] = [
  [31,119,180,200], [255,127,14,200], [44,160,44,200], [214,39,40,200],
  [148,103,189,200], [140,86,75,200], [227,119,194,200], [127,127,127,200],
  [188,189,34,200], [23,190,207,200], [174,199,232,200], [255,187,120,200],
  [152,223,138,200], [255,152,150,200], [197,176,213,200], [196,156,148,200],
  [247,182,210,200], [199,199,199,200], [219,219,141,200], [158,218,229,200],
];
```

Build a `labelIndex` Map inside the useMemo for layers: collect unique label values from points (sorted alphabetically), map each to an index. This ensures stable color assignment.

Update the `getFillColor` accessor in the ScatterplotLayer:

```typescript
getFillColor: (d) => {
  // Lasso selection overrides color mode
  if (selectedSet !== null) {
    return selectedSet.has(d.sampleId)
      ? [99, 102, 241, 230]
      : [180, 180, 180, 80];
  }
  if (colorMode === "gt_class" && d.gtLabel) {
    return CATEGORICAL_PALETTE[labelIndex.get(d.gtLabel)! % CATEGORICAL_PALETTE.length];
  }
  if (colorMode === "pred_class" && d.predLabel) {
    return CATEGORICAL_PALETTE[labelIndex.get(d.predLabel)! % CATEGORICAL_PALETTE.length];
  }
  if (colorMode === "correctness") {
    if (!d.predLabel) return [180, 180, 180, 100] as [number,number,number,number]; // no prediction: gray
    return d.gtLabel === d.predLabel
      ? [44, 160, 44, 200] as [number,number,number,number]   // correct: green
      : [214, 39, 40, 200] as [number,number,number,number];  // incorrect: red
  }
  return [100, 120, 220, 200]; // default blue
}
```

Add `colorMode` to the `updateTriggers.getFillColor` array so deck.gl re-renders when color mode changes.

Add `colorMode` to the useMemo dependency array for layers.

**2. Add color mode dropdown to EmbeddingPanel (embedding-panel.tsx):**

Add `datasetType` prop to EmbeddingPanelProps:

```typescript
interface EmbeddingPanelProps {
  datasetId: string;
  datasetType?: string;
}
```

Add color mode state: `const [colorMode, setColorMode] = useState<ColorMode>("default");`

Import `ColorMode` from embedding-scatter.tsx.

Determine `hasPredictions` from the coordinates data: `const hasPredictions = useMemo(() => coordinates?.some(p => p.predLabel != null) ?? false, [coordinates]);`

In the toolbar (between the "N points" label and the lasso button), add the color mode dropdown (only visible when coordinates are loaded):

```tsx
<select
  value={colorMode}
  onChange={(e) => setColorMode(e.target.value as ColorMode)}
  className="rounded border border-zinc-300 dark:border-zinc-600 bg-white dark:bg-zinc-800 text-xs px-2 py-1 text-zinc-900 dark:text-zinc-100"
>
  <option value="default">Default</option>
  <option value="gt_class">GT Class</option>
  <option value="pred_class" disabled={!hasPredictions}>Predicted Class</option>
  <option value="correctness" disabled={!hasPredictions}>Correct / Incorrect</option>
</select>
```

Pass `colorMode` to the `<EmbeddingScatter>` component.

**3. Thread datasetType to EmbeddingPanel (page.tsx):**

In `frontend/src/app/datasets/[datasetId]/page.tsx`, find where `<EmbeddingPanel>` is rendered and add `datasetType={dataset?.dataset_type}` prop. This enables the panel to know whether to show color mode controls.

Note: The color mode dropdown should always be shown (not just for classification) since detection datasets also have GT/pred annotations. The `hasPredictions` check handles disabling prediction-dependent modes.

**4. Invalidate embedding coordinates after prediction import:**

In the prediction import dialog or wherever predictions are imported, add `embedding-coordinates` to the list of query keys invalidated on import success. Check `frontend/src/components/detail/prediction-import-dialog.tsx` for the `onSuccess` callback of the prediction import mutation -- add:
```typescript
queryClient.invalidateQueries({ queryKey: ["embedding-coordinates", datasetId] });
```

This prevents stale coordinates (missing predLabel) after importing predictions (Pitfall 4 from research).
  </action>
  <verify>
Run `cd frontend && npx tsc --noEmit` to confirm no type errors.
Verify that the EmbeddingPanel toolbar has the color mode dropdown.
Verify that EmbeddingScatter accepts and uses the colorMode prop.
Verify that the page passes datasetType to EmbeddingPanel.
  </verify>
  <done>
Embedding scatter plot supports 4 color modes: Default (uniform blue), GT Class (categorical palette), Predicted Class (categorical palette), and Correct/Incorrect (green/red/gray). Color mode dropdown in toolbar with prediction-dependent options disabled when no predictions. Embedding coordinates cache invalidated after prediction import.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` passes with no errors
2. Backend `get_coordinates` SQL includes LEFT JOIN annotations and returns gtLabel/predLabel
3. EmbeddingPoint type has optional gtLabel/predLabel fields
4. EmbeddingScatter getFillColor branches on colorMode with categorical palette
5. EmbeddingPanel toolbar has color mode dropdown
6. Prediction-dependent modes disabled when hasPredictions is false
7. Page passes datasetType to EmbeddingPanel
8. Prediction import invalidates embedding-coordinates query key
</verification>

<success_criteria>
- Color mode dropdown visible in embedding toolbar
- Points change color when switching modes (GT Class, Predicted Class, Correct/Incorrect)
- Predicted Class and Correct/Incorrect disabled when no predictions imported
- Backend returns gtLabel and predLabel without breaking existing consumers
- No regressions to lasso selection, hover tooltip, or detection embedding functionality
</success_criteria>

<output>
After completion, create `.planning/phases/17-classification-polish/17-02-SUMMARY.md`
</output>
