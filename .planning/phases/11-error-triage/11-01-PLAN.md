---
phase: 11-error-triage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/triage.py
  - app/services/triage.py
  - app/routers/triage.py
  - app/main.py
  - frontend/src/types/triage.ts
  - frontend/src/hooks/use-triage.ts
autonomous: true

must_haves:
  truths:
    - "PATCH /samples/set-triage-tag atomically replaces previous triage tag on a sample"
    - "DELETE /samples/{sample_id}/triage-tag removes all triage tags from a sample"
    - "GET /datasets/{dataset_id}/worst-images returns ranked samples by composite error score"
    - "Frontend hook useSetTriageTag calls set-triage-tag and invalidates samples + filter-facets"
    - "Frontend hook useWorstImages fetches worst-images endpoint with source, IoU, conf params"
  artifacts:
    - path: "app/models/triage.py"
      provides: "SetTriageTagRequest, TriageScore, WorstImagesResponse Pydantic models"
      exports: ["SetTriageTagRequest", "TriageScore", "WorstImagesResponse"]
    - path: "app/services/triage.py"
      provides: "compute_worst_images scoring logic"
      exports: ["compute_worst_images"]
    - path: "app/routers/triage.py"
      provides: "set-triage-tag, remove-triage-tag, worst-images endpoints"
      exports: ["router"]
    - path: "frontend/src/types/triage.ts"
      provides: "TriageScore, WorstImagesResponse TypeScript types"
    - path: "frontend/src/hooks/use-triage.ts"
      provides: "useSetTriageTag, useRemoveTriageTag, useWorstImages hooks"
  key_links:
    - from: "app/routers/triage.py"
      to: "app/services/triage.py"
      via: "compute_worst_images import"
      pattern: "from app\\.services\\.triage import compute_worst_images"
    - from: "app/routers/triage.py"
      to: "app/services/error_analysis.py"
      via: "categorize_errors used by compute_worst_images"
      pattern: "categorize_errors"
    - from: "frontend/src/hooks/use-triage.ts"
      to: "/samples/set-triage-tag"
      via: "apiPatch call"
      pattern: "apiPatch.*set-triage-tag"
    - from: "frontend/src/hooks/use-triage.ts"
      to: "/datasets/.*/worst-images"
      via: "apiFetch call"
      pattern: "apiFetch.*worst-images"
---

<objective>
Build the backend triage infrastructure (set-triage-tag endpoint, worst-images scoring service, worst-images endpoint) and frontend data-layer hooks for triage operations.

Purpose: Provides the data mutation and fetching layer that Plan 02's UI components will consume. The set-triage-tag endpoint atomically replaces any previous triage tag (avoiding the pitfall of accumulating multiple triage tags). The worst-images service computes a composite score from error_count (60%) and confidence_spread (40%).

Output: Three backend files (models, service, router), two frontend files (types, hooks), and router registration in main.py.
</objective>

<execution_context>
@/Users/ortizeg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ortizeg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-error-triage/11-RESEARCH.md

@app/routers/samples.py (existing bulk-tag/untag pattern, DuckDB list operations)
@app/services/error_analysis.py (categorize_errors function, ErrorSample model, _MAX_SAMPLES_PER_TYPE)
@app/models/error_analysis.py (ErrorAnalysisResponse, ErrorSample models)
@app/models/sample.py (BulkTagRequest pattern)
@app/dependencies.py (get_db, get_cursor DI patterns)
@frontend/src/hooks/use-tags.ts (useBulkTag/useBulkUntag mutation pattern)
@frontend/src/hooks/use-error-analysis.ts (useErrorAnalysis query pattern)
@frontend/src/lib/api.ts (apiFetch, apiPatch, apiDelete helpers)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend triage models, service, and router</name>
  <files>
    app/models/triage.py
    app/services/triage.py
    app/routers/triage.py
    app/main.py
  </files>
  <action>
    **1. Create `app/models/triage.py`:**
    - `SetTriageTagRequest(BaseModel)`: fields `dataset_id: str`, `sample_id: str`, `tag: str`
    - `TriageScore(BaseModel)`: fields `sample_id: str`, `error_count: int`, `confidence_spread: float`, `score: float`
    - `WorstImagesResponse(BaseModel)`: field `items: list[TriageScore]`
    - Define `TRIAGE_PREFIX = "triage:"` and `VALID_TRIAGE_TAGS = {"triage:fp", "triage:tp", "triage:fn", "triage:mistake"}` as module-level constants

    **2. Create `app/services/triage.py`:**
    - Function `compute_worst_images(cursor, dataset_id, source, iou_threshold, conf_threshold, split=None, limit=50) -> list[TriageScore]`
    - Import and call `categorize_errors()` from `app.services.error_analysis`
    - Aggregate per-sample error counts from `result.samples_by_type`: iterate all error types (hard_fp, label_error, false_negative), count non-TP detections per sample_id, collect confidence values
    - Compute `confidence_spread = float(np.std(confidences))` per sample (0.0 if fewer than 2 confidences)
    - Normalize: `norm_errors = error_count / max_errors` (guard div-by-zero with `or 1`), `norm_spread = confidence_spread / max_spread` (guard with `or 1.0`)
    - Composite score: `0.6 * norm_errors + 0.4 * norm_spread`
    - Sort descending by score, return top `limit` as `TriageScore` objects
    - Return empty list if no errors found
    - Import numpy for std calculation

    **3. Create `app/routers/triage.py`:**
    - Router with `prefix="/samples"`, `tags=["triage"]` (triage endpoints live under /samples namespace)
    - `PATCH /samples/set-triage-tag`: accepts `SetTriageTagRequest`, validates `request.tag in VALID_TRIAGE_TAGS` (raise HTTPException 400 if invalid), uses DuckDB single SQL: `UPDATE samples SET tags = list_distinct(list_append(list_filter(COALESCE(tags, []), x -> NOT starts_with(x, ?)), ?)) WHERE dataset_id = ? AND id = ?` with params `[TRIAGE_PREFIX, request.tag, request.dataset_id, request.sample_id]`. Returns `{"sample_id": ..., "tag": ...}`.
    - `DELETE /samples/{sample_id}/triage-tag`: accepts `dataset_id` as Query param, removes all triage tags: `UPDATE samples SET tags = list_filter(COALESCE(tags, []), x -> NOT starts_with(x, ?)) WHERE dataset_id = ? AND id = ?` with params `[TRIAGE_PREFIX, dataset_id, sample_id]`. Returns `{"sample_id": ..., "cleared": True}`.
    - Add a second router with `prefix="/datasets"`, `tags=["triage"]` for the worst-images endpoint
    - `GET /datasets/{dataset_id}/worst-images`: accepts `source: str = Query("prediction")`, `iou_threshold: float = Query(0.5, ge=0.1, le=1.0)`, `conf_threshold: float = Query(0.25, ge=0.0, le=1.0)`, `split: str | None = Query(None)`, `limit: int = Query(50, ge=1, le=200)`. Uses `get_db` dependency. Verifies dataset exists (404 if not). Calls `compute_worst_images()`. Returns `WorstImagesResponse(items=scores)`.
    - Use `get_db` DI pattern (not `get_cursor`) matching existing statistics.py router style. Create cursor manually in try/finally.
    - Export both routers: `samples_router` and `datasets_router` (or use a single module with two router objects)

    **4. Register routers in `app/main.py`:**
    - Import both triage routers
    - Add `app.include_router(triage.samples_router)` and `app.include_router(triage.datasets_router)` following existing pattern
    - Place after existing router includes

    **Important:** The triage router for samples uses the same `/samples` prefix as the existing samples router. This is fine -- FastAPI merges routes. But ensure the endpoint paths are unique (set-triage-tag and {sample_id}/triage-tag don't conflict with existing routes).
  </action>
  <verify>
    Run `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && python -c "from app.routers.triage import samples_router, datasets_router; print('routers OK')"` to verify imports.
    Run `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && python -c "from app.services.triage import compute_worst_images; print('service OK')"` to verify service.
    Run `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor && python -m pytest tests/ -x -q` to ensure no regressions.
  </verify>
  <done>
    - PATCH /samples/set-triage-tag endpoint exists and validates against VALID_TRIAGE_TAGS
    - DELETE /samples/{sample_id}/triage-tag endpoint exists
    - GET /datasets/{dataset_id}/worst-images endpoint exists and returns WorstImagesResponse
    - compute_worst_images service computes composite score with 60/40 weighting
    - Both routers registered in main.py
    - All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend triage types and hooks</name>
  <files>
    frontend/src/types/triage.ts
    frontend/src/hooks/use-triage.ts
  </files>
  <action>
    **1. Create `frontend/src/types/triage.ts`:**
    ```typescript
    export interface TriageScore {
      sample_id: string;
      error_count: number;
      confidence_spread: number;
      score: number;
    }

    export interface WorstImagesResponse {
      items: TriageScore[];
    }

    export const TRIAGE_OPTIONS = [
      { tag: "triage:tp", label: "TP", colorClass: "bg-green-500 hover:bg-green-600", textClass: "text-green-600 dark:text-green-400" },
      { tag: "triage:fp", label: "FP", colorClass: "bg-red-500 hover:bg-red-600", textClass: "text-red-600 dark:text-red-400" },
      { tag: "triage:fn", label: "FN", colorClass: "bg-orange-500 hover:bg-orange-600", textClass: "text-orange-600 dark:text-orange-400" },
      { tag: "triage:mistake", label: "Mistake", colorClass: "bg-amber-500 hover:bg-amber-600", textClass: "text-amber-600 dark:text-amber-400" },
    ] as const;

    export type TriageTag = (typeof TRIAGE_OPTIONS)[number]["tag"];
    ```

    **2. Create `frontend/src/hooks/use-triage.ts`:**
    - `useSetTriageTag()`: useMutation calling `apiPatch<{sample_id: string; tag: string}>("/samples/set-triage-tag", body)` where body is `{dataset_id, sample_id, tag}`. On success, invalidate `["samples"]` and `["filter-facets"]` query keys (same pattern as useBulkTag).
    - `useRemoveTriageTag()`: useMutation calling `apiDelete("/samples/${sampleId}/triage-tag?dataset_id=${datasetId}")`. Accept `{dataset_id: string; sample_id: string}` as mutation input. On success, invalidate `["samples"]` and `["filter-facets"]`.
    - `useWorstImages(datasetId, source, iouThreshold, confThreshold, split, enabled)`: useQuery with queryKey `["worst-images", datasetId, source, iouThreshold, confThreshold, split]`. Fetches `apiFetch<WorstImagesResponse>(/datasets/${datasetId}/worst-images?source=...&iou_threshold=...&conf_threshold=...&split=...)`. Set `staleTime: 30_000`, `placeholderData: keepPreviousData`, `enabled: !!datasetId && enabled`. Build query string carefully, only appending `&split=...` if split is not null.
    - Follow exact patterns from `use-tags.ts` (mutations) and `use-error-analysis.ts` (query with threshold params).
  </action>
  <verify>
    Run `cd /Users/ortizeg/1Projects/⛹️‍♂️\ Next\ Play/code/data-visor/frontend && npx tsc --noEmit` to verify TypeScript compiles with 0 errors.
  </verify>
  <done>
    - frontend/src/types/triage.ts exports TriageScore, WorstImagesResponse, TRIAGE_OPTIONS, TriageTag
    - frontend/src/hooks/use-triage.ts exports useSetTriageTag, useRemoveTriageTag, useWorstImages
    - TypeScript compiles with 0 errors
  </done>
</task>

</tasks>

<verification>
1. Backend: `python -c "from app.main import app; print([r.path for r in app.routes])"` shows /samples/set-triage-tag, /samples/{sample_id}/triage-tag, /datasets/{dataset_id}/worst-images
2. Backend: `python -m pytest tests/ -x -q` -- all existing tests pass
3. Frontend: `npx tsc --noEmit` -- 0 errors
4. Types: TRIAGE_OPTIONS constant has exactly 4 entries (tp, fp, fn, mistake)
</verification>

<success_criteria>
- Backend has three new endpoints (set-triage-tag, remove-triage-tag, worst-images) with proper validation
- Triage service computes composite score with error_count (60%) + confidence_spread (40%) weighting
- Frontend has typed hooks for all three operations with proper cache invalidation
- All existing tests pass, TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/11-error-triage/11-01-SUMMARY.md`
</output>
